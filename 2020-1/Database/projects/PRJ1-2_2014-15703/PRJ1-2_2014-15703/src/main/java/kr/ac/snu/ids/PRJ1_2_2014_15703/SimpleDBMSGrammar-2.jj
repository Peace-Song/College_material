options{  //keywords can be both upper or lower case  IGNORE_CASE = true;}PARSER_BEGIN(SimpleDBMSParser)package kr.ac.snu.ids.PRJ1_2_2014_15703;import java.io.UnsupportedEncodingException;import java.io.File;import java.io.Serializable;import java.util.ArrayList;	// For easier management of data structureimport com.sleepycat.je.Database;import com.sleepycat.je.DatabaseException;import com.sleepycat.je.DatabaseConfig;import com.sleepycat.je.DatabaseEntry;import com.sleepycat.je.Cursor;import com.sleepycat.je.LockMode;import com.sleepycat.je.OperationStatus;import com.sleepycat.je.Environment;import com.sleepycat.je.EnvironmentConfig;import com.sleepycat.bind.serial.SerialBinding;	// For Serialized store and loadimport com.sleepycat.bind.serial.StoredClassCatalog;public class SimpleDBMSParser{  //constants to distinguish query and print outputs.  public static final int PRINT_SYNTAX_ERROR = 0;  public static final int PRINT_CREATE_TABLE = 1;  public static final int PRINT_DROP_TABLE = 2;  public static final int PRINT_DESC = 3;  public static final int PRINT_INSERT = 4;  public static final int PRINT_DELETE = 5;  public static final int PRINT_SELECT = 6;  public static final int PRINT_SHOW_TABLES = 7;  // Environment & Database define  public static Environment myDbEnvironment = null;  public static Database myDatabase = null;  public static Database classDB = null;  public static Cursor cursor = null;  public static SerialBinding serialBinding = null;  public static StoredClassCatalog storedClassCatalog = null;  public static void main(String args[]) throws ParseException  {	/* Opening DB */    // Open Database Environment or if not, create one.    EnvironmentConfig envConfig = new EnvironmentConfig();    envConfig.setAllowCreate(true);    myDbEnvironment  = new Environment(new File("db/"), envConfig);    // Open Database or if not, create one.    DatabaseConfig dbConfig = new DatabaseConfig();    dbConfig.setAllowCreate(true);    dbConfig.setSortedDuplicates(true);    dbConfig.setDeferredWrite(true);    myDatabase = myDbEnvironment.openDatabase(null, "sampleDatabase", dbConfig);	dbConfig.setSortedDuplicates(false);    classDB = myDbEnvironment.openDatabase(null, "classDB", dbConfig); // For SerialBinding to serialize tables    storedClassCatalog = new StoredClassCatalog(classDB);	serialBinding = new SerialBinding(storedClassCatalog, Table.class);  	cursor = myDatabase.openCursor(null, null);    // Project 1-1 Parser
    SimpleDBMSParser parser = new SimpleDBMSParser(System.in);    // prompt when program starts    System.out.print("DB_2014-15703> ");        while (true)    {      try      {        parser.command();      }      catch (Exception e)      {        printMessage(PRINT_SYNTAX_ERROR);        SimpleDBMSParser.ReInit(System.in);        // prompt after syntax error        System.out.print("DB_2014-15703> ");      }    }  }  public static void printMessage(int q)  {    //q is given by query() below    switch(q)    {      case PRINT_SYNTAX_ERROR:      	System.out.println("Syntax error");      	break;      /*case PRINT_CREATE_TABLE:      	System.out.println("\'CREATE TABLE\' requested");      	break;      case PRINT_DROP_TABLE:      	System.out.println("\'DROP TABLE\' requested");      	break;      case PRINT_DESC:      	System.out.println("\'DESC\' requested");      	break;*/      case PRINT_INSERT:      	System.out.println("\'INSERT\' requested");      	break;      case PRINT_DELETE:      	System.out.println("\'DELETE\' requested");      	break;      case PRINT_SELECT:      	System.out.println("\'SELECT\' requested");      	break;      /*case PRINT_SHOW_TABLES:      	System.out.println("\'SHOW TABLES\' requested");      	break;*/    }  }  /* Functions */  /* Takes a table, serialize it, and store it to DB. */  public static void storeTableToDB(Table table){    String tableName = table.getTableName();    DatabaseEntry key;    DatabaseEntry value = new DatabaseEntry();    try {		key = new DatabaseEntry(tableName.getBytes("UTF-8"));		// Serialize table.		serialBinding.objectToEntry(table, value);		// Store to DB.		cursor.put(key, value);		myDatabase.sync();    } catch (DatabaseException de) {    } catch (UnsupportedEncodingException e) {	  e.printStackTrace();    }   }  /* Takes a table name and returns the table thereof. */  public static Table loadTableFromDB(String tableName){ 	DatabaseEntry foundKey = new DatabaseEntry();	DatabaseEntry foundValue = new DatabaseEntry();	Table foundTable;	// Retrieve the first element in the DB.    if(cursor.getFirst(foundKey, foundValue, LockMode.DEFAULT) == OperationStatus.NOTFOUND) {		// DB is empty.		return null;	}	do {		try {		    String resKeyString = new String(foundKey.getData(), "UTF-8");			// If retrieved table name matches, deserialize and return the table.			if(resKeyString.equalsIgnoreCase(tableName)) {				foundTable = (Table) serialBinding.entryToObject(foundValue);				return foundTable;			}		} catch (DatabaseException de) {		} catch (UnsupportedEncodingException e) {	  		e.printStackTrace();		} 	} while(cursor.getNext(foundKey, foundValue, LockMode.DEFAULT) == OperationStatus.SUCCESS);	// The table is not in the DB.	return null;  }  /* Takes a table name and element list, and returns the table thereof. */  static Table makeTable(String tableName, TableElementList tableElements) throws Exception{	Table table = new Table();	Table referencedTable;    ArrayList<TableColumn> columns = tableElements.getColumnList();	ArrayList<TableConstraint> constraints = tableElements.getConstraintList();	table.setTableName(tableName);	// There is already a table in DB with same name.	if(existTable(tableName))	  	throw new Exception("Create table has failed: table with the same name already exists"); 	// Add Attributes to the table.	for(TableColumn column : columns) {		String columnName = column.getColumnName();		String columnType = column.getType();		boolean nullable = column.getNullable();		Attribute attribute;		// Check if char length < 1.		if(columnType.equals("CharLengthError")) {			throw new Exception("Char length should be over 0");		}		// Check for duplicate attributes.		for(Attribute attr : table.getAttributes()) {			if(attr.getAttributeName().equalsIgnoreCase(columnName)) {			    throw new Exception("Create table has failed: column definition is duplicated");			}		}		// Add the attribute to the table.		attribute = new Attribute(tableName, columnName, columnType, nullable);		table.addAttribute(attribute);	}	// Check constraints.	if(!constraints.isEmpty()) { 		for(TableConstraint constraint : constraints) {			// Constraint is a PK constraint.			if(constraint.getIs_PK()) {	// PK				ArrayList<String> attributes = constraint.getAttributes();				ArrayList<Attribute> tableAttributes = table.getAttributes();					// Check if there is already a PK.				if(!table.getPrimaryKey().isEmpty()) {				  throw new Exception("Create table has failed: primary key definition is duplicated");				}					// Check if attributes are in the table.				for(String attr : attributes) {					boolean isInTableAttr = false;					for(Attribute tableAttr : tableAttributes) {						if(attr.equalsIgnoreCase(tableAttr.getAttributeName())) { 							isInTableAttr = true;							break;						}					}						if(!isInTableAttr)						throw new Exception(String.format("Create table has failed: '%s' does not exist in column definition", attr));				}				// Add attributes to the PK.				table.addPrimaryKeys(attributes);					// Set nullable as false to attributes marked as PK.				for(String attr : attributes) { 					for(Attribute tableAttr : tableAttributes) {						if(attr.equalsIgnoreCase(tableAttr.getAttributeName()))							tableAttr.setNullable(false);					}				}			}			// Constraint is a FK constraint.			else {				ArrayList<String> attributes = constraint.getAttributes();				ArrayList<Attribute> tableAttributes = table.getAttributes();				String referencedTableName = constraint.getReferencedTable();				ArrayList<String> referencedAttributes = constraint.getReferencedAttribute();					// Check if referencing attributes are in the table.				for(String attr : attributes) {					boolean isInTableAttr = false;					for(Attribute tableAttr : tableAttributes) {						if(attr.equalsIgnoreCase(tableAttr.getAttributeName())) { 							isInTableAttr = true;							break;						}					}						if(!isInTableAttr)						throw new Exception(String.format("Create table has failed: '%s' does not exist in column definition", attr));				}					// Retrieve the referenced table from DB. If null, raise exception.				if((referencedTable = loadTableFromDB(referencedTableName)) == null) {					throw new Exception("Create table has failed: foreign key references non existing table");				}					// Check if referenced attributes are in the referenced table and if they are PK of the referenced table.				for(String refAttr : referencedAttributes) {					boolean isInTableAttr = false;					boolean isPK = false;					for(Attribute refTableAttr : referencedTable.getAttributes()) {						if(refAttr.equalsIgnoreCase(refTableAttr.getAttributeName())) { 							isInTableAttr = true;														// Check further if referenced attributes are in the PK of the referenced table							for(String refTablePK : referencedTable.getPrimaryKey()) {								if(refAttr.equalsIgnoreCase(refTablePK))									isPK = true;							}							break;						}					}					// Referenced attributes are not in the referenced table.					if(!isInTableAttr)						throw new Exception("Create table has failed: foreign key references non existing column");					// Referenced attributes are not PK, or they are not enough to constitute the entire PK.					if(!isPK || (isPK && referencedTable.getPrimaryKey().size() != referencedAttributes.size()))						throw new Exception("Create table has failed: foreign key references non primary key column");				}					// Check for attribute types.				for(Attribute attr : tableAttributes) {					boolean typeMatched = false;					for(Attribute refTableAttr : referencedTable.getAttributes()) {						if(attr.getTableName().equalsIgnoreCase(refTableAttr.getTableName())) {							if(!attr.getType().equalsIgnoreCase(refTableAttr.getType())) {								throw new Exception("Create table has failed: foreign key references wrong type");							}						}					}				}					// Check for attribute size.				if(attributes.size() != referencedTable.getPrimaryKey().size())					throw new Exception("Create table has failed: foreign key references wrong type");				// All constraint test passed. Assign an actual foreign key.				ArrayList<ForeignKey> foreignKeys = new ArrayList<ForeignKey>();				ForeignKey fk = new ForeignKey(attributes, referencedAttributes, referencedTableName);					table.addForeignKey(fk);				// Increment reference counter of the referenced table.				referencedTable.incrementReferenceCount();				// Overwrite the change to DB.				DatabaseEntry key = new DatabaseEntry(referencedTableName.getBytes("UTF-8"));				DatabaseEntry value = new DatabaseEntry();				serialBinding.objectToEntry(referencedTable, value);				myDatabase.delete(null, key);	 			myDatabase.put(null, key, value);	 			myDatabase.sync();			}		}	}	return table;  }  /* Takes table name and returns if the table is in the DB or not. */  static boolean existTable(String tableName) {	Table table = loadTableFromDB(tableName);	if(table == null)		return false;	else		return true;  }} // SimpleDBMSParser/* Table definition *//* All classes are serializables so that they are able to go in to the DB. */class Table implements Serializable {	String tableName;	ArrayList<Attribute> attributes;	ArrayList<ForeignKey> foreignKey;	ArrayList<String> primaryKey;	int referenceCount;	Table() {	  this.tableName = null;	  this.attributes = new ArrayList<Attribute>();	  this.foreignKey = new ArrayList<ForeignKey>();	  this.primaryKey = new ArrayList<String>();	  this.referenceCount = 0;	}	Table(	  String tableName,	  ArrayList<Attribute> attributes,	  ArrayList<ForeignKey> foreignKey,	  ArrayList<String> primaryKey	) {	  this.tableName = tableName;	  this.attributes = attributes;	  this.foreignKey = foreignKey;	  this.primaryKey = primaryKey;	  this.referenceCount = 0;	}	void addAttribute(Attribute attr) {	  this.attributes.add(attr);	}	void addPrimaryKeys(ArrayList<String> primaryKeys) {	  for(String pk : primaryKeys)		this.primaryKey.add(pk);	}	void addForeignKey(ForeignKey foreignKey) {	  this.foreignKey.add(foreignKey);	}	void incrementReferenceCount() {	  this.referenceCount++;	}	void decrementReferenceCount() {	  this.referenceCount--;	}	/* getters */	String getTableName() {	  return this.tableName;	}		ArrayList<Attribute> getAttributes() {	  return this.attributes;	}	ArrayList<ForeignKey> getForeignKey() {	  return this.foreignKey;	}	ArrayList<String> getPrimaryKey() {	  return this.primaryKey;	}	int getReferenceCount() {	  return this.referenceCount;	}	/* setters */	void setTableName(String tableName) {	  this.tableName = tableName;	}}class Attribute implements Serializable {	String tableName;	String attributeName;	String type;	boolean nullable;	Attribute() {	  this.tableName = null;	  this.attributeName = null;	  this.type = null;	  this.nullable = true;	}	Attribute(String tableName, String attributeName, String type, boolean nullable) {	  this.tableName = tableName;	  this.attributeName = attributeName;	  this.type = type;	  this.nullable = nullable;	}	/* getters */	String getTableName() {	  return this.tableName;	}	String getAttributeName() {	  return this.attributeName;	}	String getType() {	  return this.type;	}	boolean getNullable() {	  return this.nullable;	}	/* setters */	void setTableName(String tableName) {	  this.tableName = tableName;	}	void setAttributeName(String attributeName) {	  this.attributeName = attributeName;	}	void setType(String type) {	  this.type = type;	}	void setNullable(boolean nullable) {	  this.nullable = nullable;	}}class ForeignKey implements Serializable { 	ArrayList<String> referencingAttribute; 	ArrayList<String> referencedAttribute; 	String referencedTable;	ForeignKey() {	  this.referencingAttribute = new ArrayList<String>();	  this.referencedAttribute = new ArrayList<String>();	  this.referencedTable = null;	}		ForeignKey(		ArrayList<String> referencingAttribute,		ArrayList<String> referencedAttribute,		String referencedTable	) {	  this.referencingAttribute = referencingAttribute;	  this.referencedAttribute = referencedAttribute;	  this.referencedTable = referencedTable;	}	/* getters */	ArrayList<String> getReferencingAttribute() {	  return this.referencingAttribute;	}	ArrayList<String> getReferencedAttribute() {	  return this.referencingAttribute;	}	String getReferencedTable() {	  return this.referencedTable;	}}class TableElementList implements Serializable {  	ArrayList<TableColumn> columnList;  	ArrayList<TableConstraint> constraintList;  	TableElementList() {  	    this.columnList = new ArrayList<TableColumn>();  	    this.constraintList = new ArrayList<TableConstraint>();  	}  	void addColumn(TableColumn column) {  	  this.columnList.add(column);  	}  	void addConstraint(TableConstraint constraint) {  	  this.constraintList.add(constraint);  	}	/* getters */	ArrayList<TableColumn> getColumnList() {	  return this.columnList;	}	ArrayList<TableConstraint> getConstraintList() {	  return this.constraintList;	}}class TableColumn implements Serializable {  	String columnName;  	String type;  	boolean nullable;  	TableColumn(String columnName, String type, boolean nullable) {  	    this.columnName = columnName;  	    this.type = type;  	    this.nullable = nullable;  	}  	/* getters */	String getColumnName() {	  return this.columnName;	}	String getType() {	  return this.type;	}	boolean getNullable() {	  return this.nullable;	}}class TableConstraint implements Serializable {  	boolean is_PK;  	ArrayList<String> attributes;  	String referencedTable;  	ArrayList<String> referencedAttributes;  	TableConstraint(  		boolean is_PK, // true  		ArrayList<String> attributes    ) {		this.is_PK = is_PK;		this.attributes = attributes;    }  	TableConstraint(  		boolean is_PK, // false  		ArrayList<String> attributes,  		String referencedTable,  		ArrayList<String> referencedAttributes    ) {		this.is_PK = is_PK;		this.attributes = attributes;		this.referencedTable = referencedTable;		this.referencedAttributes = referencedAttributes;    }	/* getters */	boolean getIs_PK() {	  return this.is_PK;	}	ArrayList<String> getAttributes() {	  return this.attributes;	}	String getReferencedTable() {	  return this.referencedTable;	}	ArrayList<String> getReferencedAttribute() {	  return this.referencedAttributes;	}}PARSER_END(SimpleDBMSParser)SKIP : { < SPACE: " " > | <  TAB : "\t" > | < EOL : "\r\n" | "\n" | "\r" > }//key word on top of < LEGAL_IDENTIFIER > so keyword is detected firstTOKEN : /* Keywords */{  < EXIT : "exit" >| < INT : "int" >| < CHAR : "char" >| < DATE : "date" >| < CREATE : "create" >| < TABLE : "table" >| < DROP : "drop" >| < DESC : "desc" >| < INSERT : "insert" >| < INTO : "into" >| < DELETE : "delete" >| < SELECT : "select" >| < SHOW : "show" >| < TABLES : "tables" >| < VALUES : "values" >| < WHERE : "where" >| < PRIMARY : "primary" >| < FOREIGN : "foreign" >| < KEY : "key" >| < REFERENCES : "references" >| < NULL : "null" >| < NOT : "not" >| < OR : "or" >| < AS : "as" >| < FROM : "from" >| < AND : "and" >| < IS : "is" >| < ASTERISK : "*" >}//building blocks for the functions belowTOKEN :	//used in functions{  //< END : < SEMICOLON >(< SPACE > | < TAB >)*< EOL >>  < END : < SEMICOLON >(< SPACE > | < TAB >)*< EOL >>| < SEMICOLON : ";" >| < LEFT_PAREN : "(" >| < RIGHT_PAREN : ")" >| < COMMA : "," >| < PERIOD : "." >| < COMP_OP : ">" | "<" | ">=" | "<=" | "!=" | "=" >| < INT_VALUE : (< SIGN >)? (< DIGIT >)+>| < LEGAL_IDENTIFIER : < ALPHABET > (< ALPHABET > | < UNDERSCORE >)* >| < DATE_VALUE : < NNNN >"-"< NN >"-"< NN > >| < CHAR_STRING : < QUOTE >(< NON_QUOTE_CHARACTER >)*< QUOTE > >}//used to make token block aboveTOKEN :	//used to make token{  < NNNN : < DIGIT >< DIGIT >< DIGIT >< DIGIT > >| < NN : < DIGIT >< DIGIT > >| < ALPHABET : [ "a"-"z", "A"-"Z" ] >| < SIGN : "+" | "-" >	| < DIGIT : [ "0"-"9" ] >| < UNDERSCORE : "_" >| < QUOTE : "'" >| < NON_QUOTE_SPECIAL_CHARACTERS: "!" | "@" | "#" | "$" | "%" | "^" | "&" | "-" | "{" | "}" | "[" | "]" |									"~" | "`" | "+" | "*" | "_" | "=" | "\\" | "(" | ")" | "<" | ">" |									"?" | "," | "." | "\n" | "\t" | "\r" | ":" | ";" | "|" | "/">| < NON_QUOTE_CHARACTER : < DIGIT > | < ALPHABET > | < NON_QUOTE_SPECIAL_CHARACTERS > | < SPACE > >| < UNEXPECTED:~[] >}void command() :{}{  (  	queryList()  )| (    < EXIT >    (    	< SEMICOLON > | < END > 	)    {      // Close Database	  if (cursor != null) cursor.close();      if (myDatabase != null) myDatabase.close();	  if (classDB != null) classDB.close();  	  if (myDbEnvironment != null) myDbEnvironment.close();            System.exit(0);    }  )}void queryList() :{  int q;}{  (    q = query()    (  	    (	      //when query ends at end of line	      < END >		  {		    printMessage(q);		  	//prompt when new query starts		    System.out.print("DB_2014-15703> ");		  }		)	  | (	   		//for query sequence with semicolon concatenated with another query		  < SEMICOLON >		    {		      printMessage(q);		 	}		)	)  )+}int query() :{  int q;}{  //query returns q, which is used to print correct message by printMessage(q)  (    (      createTableQuery()	    {	      q = PRINT_CREATE_TABLE;	    }	  )	| (	  	dropTableQuery()	  	{	  	  q = PRINT_DROP_TABLE;	  	}	  )	| (	  	descQuery()	  	{	  	  q = PRINT_DESC;	  	}	  )	| (	  	insertQuery()	  	{	  	  q = PRINT_INSERT;	  	}	  )	| (	  	deleteQuery()	  	{	  	  q = PRINT_DELETE;	  	}	  )	| (	  	selectQuery()	  	{	  	  q = PRINT_SELECT;	  	}	  )	| (	  	showTablesQuery()	  	{	  	  q = PRINT_SHOW_TABLES;	  	} 	  )	)  {   	return q;  }}//below regex for queries are similar to the ones in grammar file. /// 0. easy onesvoid dropTableQuery() :{  String tableName;  Table table;}{	<  DROP >	< TABLE >	tableName = tableName()	{	  try { 		table = loadTableFromDB(tableName);		if(table == null) {		  System.out.println("No such table");		  return;		}		// Check if there are some tables referencing this table. If so, do not drop.		if(table.getReferenceCount() > 0) {		  System.out.println("Drop table has failed: '"+ tableName +"' is referenced by other table");		  return;		}		// For every foreign key, decrement reference counts of tables referenced by the being-dropped table.		for(ForeignKey foreignKey : table.getForeignKey()) {		  String referencedTableName = foreignKey.getReferencedTable();		  Table referencedTable = loadTableFromDB(referencedTableName);		  if(referencedTable != null) {			referencedTable.decrementReferenceCount();			// Overwrite the change to DB.		    DatabaseEntry key = new DatabaseEntry(referencedTableName.getBytes("UTF-8"));		    DatabaseEntry value = new DatabaseEntry();			serialBinding.objectToEntry(referencedTable, value);			myDatabase.delete(null, key);	 		myDatabase.put(null, key, value);	 		myDatabase.sync();		  }		}		// Drop the table from the DB.		myDatabase.delete(null, new DatabaseEntry(tableName.getBytes("UTF-8")));		myDatabase.sync();		System.out.println("'"+ tableName +"' table is dropped");	  }	  catch(Exception e) {	    e.printStackTrace();	  }	}}void descQuery() :{  String tableName;  Table table = null;}{	< DESC >	tableName = tableName()	{	  table = loadTableFromDB(tableName);	  if(table == null) {		System.out.println("No such table");		return;	  }	  System.out.println("-------------------------------------------------------------");	  System.out.println("table_name [" + tableName + "]");	  System.out.println(String.format("%-25s %-15s %-15s %-15s", "column_name", "type", "null", "key"));	  String name, type, nullable, kind;	  boolean isPK = false;	  boolean isFK = false;	  // For every attribute, determine the strings.	  for(Attribute attr : table.getAttributes()){		isPK = false;		isFK = false;		name = attr.getAttributeName();		type = attr.getType();		// Check if nullable.		if(attr.getNullable())		  nullable = "Y";		else		  nullable = "N";		// Check if the attribute is a part of PK.		for(String pk : table.getPrimaryKey())		  if(pk.equalsIgnoreCase(name))			isPK = true;		// Check if the attribute is a part of FK.		for(ForeignKey fk : table.getForeignKey())		  for(String referencingAttr : fk.getReferencingAttribute())			if(referencingAttr.equalsIgnoreCase(name))			  isFK = true;		// If both, the attribute is both a PK and a FK.	    if(isPK && isFK)		  kind = "PRI/FOR";		else if(isPK)		  kind = "PRI";		else if(isFK)		  kind = "FOR";		else		  kind = "";		System.out.println(String.format("%-25s %-15s %-15s %-15s", name, type, nullable, kind));	  }	    System.out.println("-------------------------------------------------------------");	}}void showTablesQuery() :{  String tableName = null;  DatabaseEntry foundKey;  DatabaseEntry foundData;}{	< SHOW>	< TABLES >	{	  foundKey = new DatabaseEntry();	  foundData = new DatabaseEntry();	  // There is no table in the DB.	  if(cursor.getFirst(foundKey, foundData, LockMode.DEFAULT) == OperationStatus.NOTFOUND) { 	    System.out.println("There is no table");	    return;	  }	  System.out.println("----------------");	  // Print all tables in the DB.	  do {		try {		  tableName = new String(foundKey.getData(), "UTF-8");		  System.out.println(tableName);		}		catch (UnsupportedEncodingException e) {			e.printStackTrace();		}	  } while(cursor.getNext(foundKey, foundData,LockMode.DEFAULT) == OperationStatus.SUCCESS);	  System.out.println("----------------");	}}/// 0. easy ones /// 1. for createTableQuery()void createTableQuery() :{	String tableName;	TableElementList tableElements;	Table createdTable;}{  < CREATE >  < TABLE >  tableName = tableName()  tableElements = tableElementList()  {    // Make a table out of table name and its elements, and store it to the DB.	try { 	  createdTable = makeTable(tableName, tableElements);      storeTableToDB(createdTable);    }    catch(Exception e) {	  System.out.println(e.getMessage());	  SimpleDBMSParser.ReInit(System.in);      System.out.print("DB_2014-15703> ");    }  }}TableElementList tableElementList() :{  TableElementList tableElements = new TableElementList();}{  < LEFT_PAREN >  tableElements = tableElement(tableElements)  (    < COMMA >    tableElements = tableElement(tableElements)  )*  < RIGHT_PAREN >  {	return tableElements;  }}TableElementList tableElement(TableElementList tableElements) :{}{  (    tableElements = columnDefinition(tableElements)  | tableElements = tableConstraintDefinition(tableElements)  )  {	return tableElements;  }}TableElementList columnDefinition(TableElementList tableElements) :{  String columnName;  String dataType;  boolean nullable;  Token T = null;  TableColumn column;}{  columnName = columnName()  dataType = dataType()  (    < NOT >    T = < NULL >  )?  {    nullable = T == null ? true : false;	column = new TableColumn(columnName, dataType, nullable);	tableElements.addColumn(column);	return tableElements;  }}TableElementList tableConstraintDefinition(TableElementList tableElements) :{}{  (    tableElements = primaryKeyConstraint(tableElements)  | tableElements = referentialConstraint(tableElements)  )  {	return tableElements;  }}TableElementList primaryKeyConstraint(TableElementList tableElements) :{  boolean is_PK = true;  ArrayList<String> primaryKeyList;  TableConstraint constraint;}{  < PRIMARY >  < KEY >  primaryKeyList = columnNameList()  {    constraint = new TableConstraint(is_PK, primaryKeyList);    tableElements.addConstraint(constraint);    return tableElements;  }}TableElementList referentialConstraint(TableElementList tableElements) :{  boolean is_PK = false;  ArrayList<String> foreignKeyList;  TableConstraint constraint;  String tableName;  ArrayList<String> referencedAttributes;}{  < FOREIGN >  < KEY >  foreignKeyList = columnNameList()  < REFERENCES >  tableName = tableName()  referencedAttributes = columnNameList()  {	constraint = new TableConstraint(is_PK, foreignKeyList, tableName, referencedAttributes);	tableElements.addConstraint(constraint);	return tableElements;  }}ArrayList<String> columnNameList() :{  String columnName;  ArrayList<String> columnNames = new ArrayList<String>();}{  < LEFT_PAREN >  columnName = columnName()  {	columnNames.add(columnName);  }  (    < COMMA >    columnName = columnName()    {      columnNames.add(columnName);    }  )*  < RIGHT_PAREN >  {	return columnNames;  }}String dataType() :{  Token type = null;  Token val = null;  Token left = null;  Token right = null;  String result;}{  (	type = < INT >  | (	  type = < CHAR >	  left = < LEFT_PAREN >	  val = < INT_VALUE >	  right = < RIGHT_PAREN >	)  | type = < DATE >  )  {    // INT or DATE	if(type.image.equalsIgnoreCase("int") || type.image.equalsIgnoreCase("date")) {	  result = type.image;	}		// CHAR	else {	  // Its value is not right.	  if(Integer.parseInt(val.image) <  1) {	    result = "CharLengthError";	  }	  // Good case.	  else { 	    result = type.image + left.image + val.image + right.image;	  }	}	return result;  }}String tableName() :{  Token T;}{  T = < LEGAL_IDENTIFIER >  {    return T.image;  }}String columnName() :{  Token T;}{  T = < LEGAL_IDENTIFIER >  {	return T.image;  }}/// 1. for createTableQuery/// 2. for selectQueryvoid selectQuery() :{}{	< SELECT >	selectList()	tableExpression()}void selectList() :{}{  < ASTERISK >| (  	selectedColumn()  	(  	  < COMMA >  	  selectedColumn()  	)*  )}void selectedColumn() :{}{	(	  //tableName & columnName are same token <LEGAL_IDENITFIER >, so need to lookahead 2	  LOOKAHEAD(2)	  tableName()	  < PERIOD >	)?	columnName()	(	  < AS >	  columnName()	)?}void tableExpression():{}{	fromClause()	(		whereClause()	)?}void fromClause():{}{  < FROM >  tableReferenceList()}void tableReferenceList():{}{  referedTable()  (    < COMMA >    referedTable()  )*}void referedTable():{}{  tableName()  (    < AS >    tableName()  )?}void whereClause() :{}{  < WHERE >  booleanValueExpression()}void booleanValueExpression() :{}{  booleanTerm()  (    < OR >    booleanTerm()  )*}void booleanTerm():{}{  booleanFactor()  (    < AND >    booleanFactor()  )*}void booleanFactor():{}{  (    < NOT >  )?  booleanTest()}void booleanTest():{}{  predicate()| parenthesizedBooleanExpression()}void parenthesizedBooleanExpression():{}{  < LEFT_PAREN >  booleanValueExpression()  < RIGHT_PAREN >}void predicate():{}{  //comparisonPredicate & nullPredicate can both start with tableName()< PERIOD >columnName()  //so need to lookahead 4  LOOKAHEAD(4)  comparisonPredicate()| nullPredicate() }void comparisonPredicate():{}{	compOperand()	< COMP_OP >	compOperand() }void compOperand():{}{  comparableValue()| (  	(  	  //tableName & columnName are same token <LEGAL_IDENITFIER >, so need to lookahead 2  	  LOOKAHEAD(2)  	  tableName()  	  < PERIOD >  	)?  	columnName() )}void comparableValue():{}{  < INT_VALUE >| < CHAR_STRING >| < DATE_VALUE >}void nullPredicate():{}{  (    //tableName & columnName are same token <LEGAL_IDENITFIER >, so need to lookahead 2    LOOKAHEAD(2)    tableName()    < PERIOD >  )?  columnName()  nullOperation()}void nullOperation():{}{  < IS >  (    (      < NOT >    )?  	< NULL >  )}/// 2. for selectQuery/// 3. for insert,deletevoid insertQuery() :{}{	< INSERT >	< INTO >	tableName()	insertColumnsAndSource()}void deleteQuery() :{}{	< DELETE >	< FROM > 	tableName()	(		whereClause()	)?}void insertColumnsAndSource() :{}{	(	  columnNameList()	)?	valueList()}void valueList() :{}{	< VALUES >	< LEFT_PAREN >	value()	(	  < COMMA >	  value()	)*	< RIGHT_PAREN >}void value() :{}{	< NULL >|  comparableValue()}/// 3. for insert,delete