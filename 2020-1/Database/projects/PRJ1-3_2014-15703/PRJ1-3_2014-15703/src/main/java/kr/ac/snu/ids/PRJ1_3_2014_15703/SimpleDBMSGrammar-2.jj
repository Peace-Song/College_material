options{  //keywords can be both upper or lower case  IGNORE_CASE = true;}PARSER_BEGIN(SimpleDBMSParser)package kr.ac.snu.ids.PRJ1_3_2014_15703;import java.io.UnsupportedEncodingException;import java.io.File;import java.io.Serializable;import java.util.ArrayList;	// For easier management of data structureimport com.sleepycat.je.Database;import com.sleepycat.je.DatabaseException;import com.sleepycat.je.DatabaseConfig;import com.sleepycat.je.DatabaseEntry;import com.sleepycat.je.Cursor;import com.sleepycat.je.LockMode;import com.sleepycat.je.OperationStatus;import com.sleepycat.je.Environment;import com.sleepycat.je.EnvironmentConfig;import com.sleepycat.bind.serial.SerialBinding;	// For Serialized store and loadimport com.sleepycat.bind.serial.StoredClassCatalog;public class SimpleDBMSParser{  //constants to distinguish query and print outputs.  public static final int PRINT_SYNTAX_ERROR = 0;  public static final int PRINT_CREATE_TABLE = 1;  public static final int PRINT_DROP_TABLE = 2;  public static final int PRINT_DESC = 3;  public static final int PRINT_INSERT = 4;  public static final int PRINT_DELETE = 5;  public static final int PRINT_SELECT = 6;  public static final int PRINT_SHOW_TABLES = 7;  // Environment & Database define  public static Environment myDbEnvironment = null;  public static Database myDatabase = null;  public static Database classDB = null;  public static Cursor cursor = null;  public static SerialBinding serialBinding = null;  public static StoredClassCatalog storedClassCatalog = null;  public static void main(String args[]) throws ParseException  {	/* Opening DB */    // Open Database Environment or if not, create one.    EnvironmentConfig envConfig = new EnvironmentConfig();    envConfig.setAllowCreate(true);    myDbEnvironment  = new Environment(new File("db/"), envConfig);    // Open Database or if not, create one.    DatabaseConfig dbConfig = new DatabaseConfig();    dbConfig.setAllowCreate(true);    dbConfig.setSortedDuplicates(true);    dbConfig.setDeferredWrite(true);    myDatabase = myDbEnvironment.openDatabase(null, "sampleDatabase", dbConfig);	dbConfig.setSortedDuplicates(false);    classDB = myDbEnvironment.openDatabase(null, "classDB", dbConfig); // For SerialBinding to serialize tables    storedClassCatalog = new StoredClassCatalog(classDB);	serialBinding = new SerialBinding(storedClassCatalog, Table.class);  	cursor = myDatabase.openCursor(null, null);    // Project 1-1 Parser
    SimpleDBMSParser parser = new SimpleDBMSParser(System.in);    // prompt when program starts    System.out.print("DB_2014-15703> ");        while (true)    {      try      {        parser.command();      }      catch (Exception e)      {        printMessage(PRINT_SYNTAX_ERROR);        SimpleDBMSParser.ReInit(System.in);        // prompt after syntax error        System.out.print("DB_2014-15703> ");      }    }  }  public static void printMessage(int q)  {    //q is given by query() below    switch(q)    {      case PRINT_SYNTAX_ERROR:      	System.out.println("Syntax error");      	break;      /*case PRINT_CREATE_TABLE:      	System.out.println("\'CREATE TABLE\' requested");      	break;      case PRINT_DROP_TABLE:      	System.out.println("\'DROP TABLE\' requested");      	break;      case PRINT_DESC:      	System.out.println("\'DESC\' requested");      	break;*/      /*case PRINT_INSERT:      	System.out.println("\'INSERT\' requested");      	break;*/      /*case PRINT_DELETE:      	System.out.println("\'DELETE\' requested");      	break;*/      /*case PRINT_SELECT:      	System.out.println("\'SELECT\' requested");      	break;*/      /*case PRINT_SHOW_TABLES:      	System.out.println("\'SHOW TABLES\' requested");      	break;*/    }  }  /* Functions */  /* Takes a table, serialize it, and store it to DB. */  public static void storeTableToDB(Table table){    String tableName = table.getTableName();    DatabaseEntry key;    DatabaseEntry value = new DatabaseEntry();    try {		key = new DatabaseEntry(tableName.getBytes("UTF-8"));		// Serialize table.		serialBinding.objectToEntry(table, value);		// Store to DB.		cursor.put(key, value);		myDatabase.sync();    } catch (DatabaseException de) {    } catch (UnsupportedEncodingException e) {	  e.printStackTrace();    }   }  /* Takes a table name and returns the table thereof. */  public static Table loadTableFromDB(String tableName){ 	DatabaseEntry foundKey = new DatabaseEntry();	DatabaseEntry foundValue = new DatabaseEntry();	Table foundTable;	// Retrieve the first element in the DB.    if(cursor.getFirst(foundKey, foundValue, LockMode.DEFAULT) == OperationStatus.NOTFOUND) {		// DB is empty.		return null;	}	do {		try {		    String resKeyString = new String(foundKey.getData(), "UTF-8");			// If retrieved table name matches, deserialize and return the table.			if(resKeyString.equalsIgnoreCase(tableName)) {				foundTable = (Table) serialBinding.entryToObject(foundValue);				return foundTable;			}		} catch (DatabaseException de) {		} catch (UnsupportedEncodingException e) {	  		e.printStackTrace();		} 	} while(cursor.getNext(foundKey, foundValue, LockMode.DEFAULT) == OperationStatus.SUCCESS);	// The table is not in the DB.	return null;  }  /* Takes a table name and element list, and returns the table thereof. */  static Table makeTable(String tableName, TableElementList tableElements) throws Exception{	Table table = new Table();	Table referencedTable;    ArrayList<TableColumn> columns = tableElements.getColumnList();	ArrayList<TableConstraint> constraints = tableElements.getConstraintList();	table.setTableName(tableName);	// There is already a table in DB with same name.	if(existTable(tableName))	  	throw new Exception("Create table has failed: table with the same name already exists"); 	// Add Attributes to the table.	for(TableColumn column : columns) {		String columnName = column.getColumnName();		String columnType = column.getType();		boolean nullable = column.getNullable();		Attribute attribute;		// Check if char length < 1.		if(columnType.equals("CharLengthError")) {			throw new Exception("Char length should be over 0");		}		// Check for duplicate attributes.		for(Attribute attr : table.getAttributes()) {			if(attr.getAttributeName().equalsIgnoreCase(columnName)) {			    throw new Exception("Create table has failed: column definition is duplicated");			}		}		// Add the attribute to the table.		attribute = new Attribute(tableName, columnName, columnType, nullable);		table.addAttribute(attribute);	}	// Check constraints.	if(!constraints.isEmpty()) { 		for(TableConstraint constraint : constraints) {			// Constraint is a PK constraint.			if(constraint.getIs_PK()) {	// PK				ArrayList<String> attributes = constraint.getAttributes();				ArrayList<Attribute> tableAttributes = table.getAttributes();					// Check if there is already a PK.				if(!table.getPrimaryKey().isEmpty()) {				  throw new Exception("Create table has failed: primary key definition is duplicated");				}					// Check if attributes are in the table.				for(String attr : attributes) {					boolean isInTableAttr = false;					for(Attribute tableAttr : tableAttributes) {						if(attr.equalsIgnoreCase(tableAttr.getAttributeName())) { 							isInTableAttr = true;							break;						}					}						if(!isInTableAttr)						throw new Exception(String.format("Create table has failed: '%s' does not exist in column definition", attr));				}				// Add attributes to the PK.				table.addPrimaryKeys(attributes);					// Set nullable as false to attributes marked as PK.				for(String attr : attributes) { 					for(Attribute tableAttr : tableAttributes) {						if(attr.equalsIgnoreCase(tableAttr.getAttributeName()))							tableAttr.setNullable(false);					}				}			}			// Constraint is a FK constraint.			else {				ArrayList<String> attributes = constraint.getAttributes();				ArrayList<Attribute> tableAttributes = table.getAttributes();				String referencedTableName = constraint.getReferencedTable();				ArrayList<String> referencedAttributes = constraint.getReferencedAttribute();					// Check if referencing attributes are in the table.				for(String attr : attributes) {					boolean isInTableAttr = false;					for(Attribute tableAttr : tableAttributes) {						if(attr.equalsIgnoreCase(tableAttr.getAttributeName())) { 							isInTableAttr = true;							break;						}					}						if(!isInTableAttr)						throw new Exception(String.format("Create table has failed: '%s' does not exist in column definition", attr));				}					// Retrieve the referenced table from DB. If null, raise exception.				if((referencedTable = loadTableFromDB(referencedTableName)) == null) {					throw new Exception("Create table has failed: foreign key references non existing table");				}					// Check if referenced attributes are in the referenced table and if they are PK of the referenced table.				for(String refAttr : referencedAttributes) {					boolean isInTableAttr = false;					boolean isPK = false;					for(Attribute refTableAttr : referencedTable.getAttributes()) {						if(refAttr.equalsIgnoreCase(refTableAttr.getAttributeName())) { 							isInTableAttr = true;														// Check further if referenced attributes are in the PK of the referenced table							for(String refTablePK : referencedTable.getPrimaryKey()) {								if(refAttr.equalsIgnoreCase(refTablePK))									isPK = true;							}							break;						}					}					// Referenced attributes are not in the referenced table.					if(!isInTableAttr)						throw new Exception("Create table has failed: foreign key references non existing column");					// Referenced attributes are not PK, or they are not enough to constitute the entire PK.					if(!isPK || (isPK && referencedTable.getPrimaryKey().size() != referencedAttributes.size()))						throw new Exception("Create table has failed: foreign key references non primary key column");				}					// Check for attribute types.				for(Attribute attr : tableAttributes) {					boolean typeMatched = false;					for(Attribute refTableAttr : referencedTable.getAttributes()) {						if(attr.getTableName().equalsIgnoreCase(refTableAttr.getTableName())) {							if(!attr.getType().equalsIgnoreCase(refTableAttr.getType())) {								throw new Exception("Create table has failed: foreign key references wrong type");							}						}					}				}					// Check for attribute size.				if(attributes.size() != referencedTable.getPrimaryKey().size())					throw new Exception("Create table has failed: foreign key references wrong type");				// All constraint test passed. Assign an actual foreign key.				ArrayList<ForeignKey> foreignKeys = new ArrayList<ForeignKey>();				ForeignKey fk = new ForeignKey(attributes, referencedAttributes, referencedTableName);					table.addForeignKey(fk);				// Increment reference counter of the referenced table.				referencedTable.incrementReferenceCount();				// Add this table as a referencing table that refers to the referenced table				referencedTable.addTableReferencedBy(tableName);				// Overwrite the change to DB.				DatabaseEntry key = new DatabaseEntry(referencedTableName.getBytes("UTF-8"));				DatabaseEntry value = new DatabaseEntry();				serialBinding.objectToEntry(referencedTable, value);				myDatabase.delete(null, key);	 			myDatabase.put(null, key, value);	 			myDatabase.sync();			}		}	}	return table;  }  /* Takes table name and returns if the table is in the DB or not. */  static boolean existTable(String tableName) {	Table table = loadTableFromDB(tableName);	if(table == null)		return false;	else		return true;  }  /* Takes table list and returns producted records. */  static ArrayList<ArrayList<String>> product(ArrayList<Table> tables) {    ArrayList<ArrayList<String>> products = new ArrayList<ArrayList<String>>();    ArrayList<ArrayList<String>> products_recordOnly = new ArrayList<ArrayList<String>>();    ArrayList<String> header = new ArrayList<String>();    // Make header    for(Table table : tables) {	  String tableName = table.getTableName();	  String aliasName = table.getAliasName();	  	  for(Attribute attr : table.getAttributes()) {	    header.add(tableName + ":" + aliasName + ":" + attr.getAttributeName() + ":" + (attr.getType().startsWith("char") ? "char" : attr.getType()));	  }    }	products.add(header);	// Return its instance if there is only one table to product	if(tables.size() == 1) {	  products.addAll(new ArrayList<ArrayList<String>>(tables.get(0).getInstance()));	  return products;	}	// For each table, conduct producting with existing one	for(int idx = 0; idx < tables.size(); idx++) {	  Table table = tables.get(idx);	  // If a table has no record, return an empty table with header only	  if(table.getInstance().size() == 0) {		return products;	  }	  // If this is the first table, initialize the products	  if(idx == 0) {	    products_recordOnly = new ArrayList<ArrayList<String>>(table.getInstance());	    continue;	  }	  products_recordOnly = productHelper(products_recordOnly, new ArrayList<ArrayList<String>>(table.getInstance()));	}	products.addAll(products_recordOnly);	return products;  }  static ArrayList<ArrayList<String>> productHelper(ArrayList<ArrayList<String>> leftInstance, ArrayList<ArrayList<String>> rightInstance) {	ArrayList<ArrayList<String>> product = new ArrayList<ArrayList<String>>();	// For each left record and for each right record,	for(ArrayList<String> leftRecord : leftInstance) {	  for(ArrayList<String> rightRecord : rightInstance) {		// Build another ArrayList object		ArrayList<String> leftRecord_temp = new ArrayList<String>(leftRecord);		// Concatenate the record		leftRecord_temp.addAll(rightRecord);		// Add it to the final product		product.add(leftRecord_temp);	  }	}	return product;  }  static int compare(String leftOperand, String rightOperand, String operator, String type) {	if(leftOperand.equals("null") || rightOperand.equals("null"))	  return -1;	if(type.equals("int")) {	  if(operator.equals("<"))	    return Integer.parseInt(leftOperand) < Integer.parseInt(rightOperand) ? 1 : 0;	  if(operator.equals(">"))	    return Integer.parseInt(leftOperand) > Integer.parseInt(rightOperand) ? 1 : 0;	  if(operator.equals("="))	    return Integer.parseInt(leftOperand) == Integer.parseInt(rightOperand) ? 1 : 0;	  if(operator.equals("<="))	    return Integer.parseInt(leftOperand) <= Integer.parseInt(rightOperand) ? 1 : 0;	  if(operator.equals(">="))	    return Integer.parseInt(leftOperand) >= Integer.parseInt(rightOperand) ? 1 : 0;	  if(operator.equals("!="))	    return Integer.parseInt(leftOperand) != Integer.parseInt(rightOperand) ? 1 : 0;	  else return -2; // to stop compiler complaint	}	else {	  if(type.equals("char")) {	    if(leftOperand.startsWith("'") && leftOperand.endsWith("'"))	      leftOperand = leftOperand.substring(1, leftOperand.length()-1);	    if(rightOperand.startsWith("'") && rightOperand.endsWith("'"))	      rightOperand = rightOperand.substring(1, rightOperand.length()-1);	  }	  if(operator.equals("<"))		return leftOperand.compareTo(rightOperand) < 0 ? 1 : 0;	  if(operator.equals(">"))		return leftOperand.compareTo(rightOperand) > 0 ? 1 : 0;	  if(operator.equals("="))		return leftOperand.compareTo(rightOperand) == 0 ? 1 : 0;	  if(operator.equals("<="))		return leftOperand.compareTo(rightOperand) <= 0 ? 1 : 0;	  if(operator.equals(">="))		return leftOperand.compareTo(rightOperand) >= 0 ? 1 : 0;	  if(operator.equals("!="))		return leftOperand.compareTo(rightOperand) != 0 ? 1 : 0;	  else return -2; // to stop compiler complaint	}  }  static int columnNameCount(String tableName, String columnName, ArrayList<String> header) {	int cnt = 0;	// table name is not specified	if(tableName.length() == 0) {	  // For each tablehdr "tableName:aliasName:attributeName:attributeIndex"	  for(String tablehdr : header) {	    String tableName_hdr = tablehdr.split(":", 4)[0];	    String aliasName_hdr = tablehdr.split(":", 4)[1];	    String columnName_hdr = tablehdr.split(":", 4)[2];		if(columnName.equalsIgnoreCase(columnName_hdr))		  cnt++;	  }	  return cnt;	}	// table name is specified	else {	  // table_cnt only need to check if 0 or not	  int table_cnt = 0;	  // For each tablehdr "tableName:aliasName:attributeName:attributeIndex"	  for(String tablehdr : header) {	    String tableName_hdr = tablehdr.split(":", 4)[0];	    String aliasName_hdr = tablehdr.split(":", 4)[1];	    String columnName_hdr = tablehdr.split(":", 4)[2];		// if table name is identical to any of these, not specified error will not be raised.		if(tableName.equalsIgnoreCase(tableName_hdr) || tableName.equalsIgnoreCase(aliasName_hdr))		  table_cnt++;		if((tableName.equalsIgnoreCase(tableName_hdr) && columnName.equalsIgnoreCase(columnName_hdr))	    || (tableName.equalsIgnoreCase(aliasName_hdr) && columnName.equalsIgnoreCase(columnName_hdr)))	      cnt++;	  }	  if(table_cnt == 0)	    return -1;	  return cnt;	}  }  static int tableNameCount(String tableName, ArrayList<String> header) {	int cnt = 0;	// For each tablehdr "tableName:aliasName:attributeName:attributeIndex"	for(String tablehdr : header) {	  String tableName_hdr = tablehdr.split(":", 4)[0];	  String aliasName_hdr = tablehdr.split(":", 4)[1];	  // If identical to either one of cases, cnt++	  if(tableName.equalsIgnoreCase(tableName_hdr) || tableName.equalsIgnoreCase(aliasName_hdr))	    cnt++;	}	return cnt;  }/*+----------------+-------------+---------+  // line 1| ACCOUNT_NUMBER | BRANCH_NAME | BALANCE |  // line 2+----------------+-------------+---------+  // line 3| A-101 		 | Downtown    | 500	 |  // line 4| A-102 	     | Perryridge  | 400	 || A-201 	     | Brighton    | 900	 || A-215 		 | Mianus      | 700	 || A-217 		 | Brighton    | 750	 || A-222 		 | Redwood     | 700	 || A-305 	     | Round Hill  | 350 	 |+----------------+-------------+---------+  // line 5*/  static void printSelected(ArrayList<String> header, ArrayList<ArrayList<String>> products) {	int padding = 10;    // line 1	for(String hdr : header) {	  String attrName = hdr.split(":", 2)[0];	  System.out.print("+");	  for(int _ = 0; _ < attrName.length() + padding; _++)	    System.out.print("-");	}	System.out.println("+");	// line 2	for(String hdr : header) {	  String attrName = hdr.split(":", 2)[0];	  System.out.print("|");	  for(int _ = 0; _ < padding / 2; _++)	    System.out.print(" ");	  System.out.print(attrName.toUpperCase());	  for(int _ = 0; _ < padding / 2; _++)	    System.out.print(" ");	}	System.out.println("|");	// line 3	for(String hdr : header) {	  String attrName = hdr.split(":", 2)[0];	  System.out.print("+");	  for(int _ = 0; _ < attrName.length() + padding; _++)	    System.out.print("-");	}	System.out.println("+");	// line 4	for(int idx = 1; idx < products.size(); idx++) {	  ArrayList<String> productedRecord = products.get(idx);	  	  for(String hdr : header) {		String attrName = hdr.split(":", 2)[0];		int attrIdx = Integer.parseInt(hdr.split(":", 2)[1]);		String valToPrint = productedRecord.get(attrIdx);		if(valToPrint.startsWith("'") && valToPrint.endsWith("'"))		  valToPrint = valToPrint.substring(1, valToPrint.length()-1);		System.out.print("|");		System.out.print(" ");		System.out.print(valToPrint);		for(int _ = 0; _ < attrName.length() - valToPrint.length() + padding - 1; _++)		  System.out.print(" "); 	  }	  System.out.println("|");	}	// line 5	for(String hdr : header) {	  String attrName = hdr.split(":", 2)[0];	  System.out.print("+");	  for(int _ = 0; _ < attrName.length() + padding; _++)	    System.out.print("-");	}	System.out.println("+");  }} // SimpleDBMSParser/* Table definition *//* All classes are serializables so that they are able to go in to the DB. */class Table implements Serializable {	String tableName;	String aliasName;	ArrayList<Attribute> attributes;	ArrayList<ForeignKey> foreignKey;	ArrayList<String> primaryKey;	int referenceCount;	ArrayList<String> tablesReferencedBy;	ArrayList<ArrayList<String>> instance;	Table() {	  this.tableName = null;	  this.aliasName = null;	  this.attributes = new ArrayList<Attribute>();	  this.foreignKey = new ArrayList<ForeignKey>();	  this.primaryKey = new ArrayList<String>();	  this.referenceCount = 0;	  this.instance = new ArrayList<ArrayList<String>>();	  this.tablesReferencedBy = new ArrayList<String>();	}	Table(	  String tableName,	  String aliasName,	  ArrayList<Attribute> attributes,	  ArrayList<ForeignKey> foreignKey,	  ArrayList<String> primaryKey	) {	  this.tableName = tableName;	  this.aliasName = aliasName;	  this.attributes = attributes;	  this.foreignKey = foreignKey;	  this.primaryKey = primaryKey;	  this.referenceCount = 0;	  this.instance = new ArrayList<ArrayList<String>>();	  this.tablesReferencedBy = new ArrayList<String>();	}	void addAttribute(Attribute attr) {	  this.attributes.add(attr);	}	void addPrimaryKeys(ArrayList<String> primaryKeys) {	  for(String pk : primaryKeys)		this.primaryKey.add(pk);	}	void addForeignKey(ForeignKey foreignKey) {	  this.foreignKey.add(foreignKey);	}	void addInstance(ArrayList<String> record) {	  this.instance.add(record);	}	void addTableReferencedBy(String table_name) {	  this.tablesReferencedBy.add(table_name);	}	void incrementReferenceCount() {	  this.referenceCount++;	}	void decrementReferenceCount() {	  this.referenceCount--;	}	boolean constitutesPK(String attrName) {	  for(String attrPK : this.primaryKey) {		if(attrPK.equalsIgnoreCase(attrName))		  return true;	  }	  return false;	}	boolean constitutesFK(String attrName, String tableName) {	  // Find a foreign key references that match the table name	  for(ForeignKey FK : this.foreignKey) {	    // Found one		if(FK.getReferencedTable().equalsIgnoreCase(tableName)) {		  ArrayList<String> refingAttrs = FK.getReferencingAttribute();		  // Check for the attribute name		  for(String refingAttr : refingAttrs) {			if(refingAttr.equalsIgnoreCase(attrName))			  return true;		  }		  // The attribute name is not in the referencing attributes in the table.		  // return false.		  return false;		}	  }	  // No such table found.	  return false;	}	boolean checkPKConstraint(ArrayList<String> candidateRecord) {	  // candidateRecord is considered to be ordered as specified in the table attributes	  // PK is defined	  if(primaryKey.size() != 0) {		ArrayList<String> candidatePK = new ArrayList<String>();		// Extract attributes from candidate record that constitute PK		for(int idx = 0; idx < this.attributes.size(); idx++) {		  String attrName = this.attributes.get(idx).getAttributeName();		  if(constitutesPK(attrName))			candidatePK.add(candidateRecord.get(idx));		}		// Not nullable constraint already checked in insertQuery()		// Check if there is a record with same PK		for(int instance_idx = 0; instance_idx < this.instance.size(); instance_idx++) {		  ArrayList<String> record = this.instance.get(instance_idx);		  ArrayList<String> recordPK = new ArrayList<String>();		  // For each record, extract its PK attributes		  for(int attr_idx = 0; attr_idx < record.size(); attr_idx++) {			String recordAttr = record.get(attr_idx);			if(constitutesPK(this.attributes.get(attr_idx).getAttributeName()))			  recordPK.add(recordAttr);		  }		  // Determine if this record's PK is same as the candidate's PK		  boolean isSame = true;		  for(int attr_idx = 0; attr_idx < recordPK.size(); attr_idx++) {			if(!recordPK.get(attr_idx).equals(candidatePK.get(attr_idx))) {			  isSame = false;			  break;			}		  }		  // If so, PK constraint is now violated		  if(isSame)		  	return false;		}		// That this instruction is executed implies there was no duplicacy		return true;	  }	  // PK is not defined - PK is considered to be all attributes	  else {	    // Check if there is a record with same attributes		for(int instance_idx = 0; instance_idx < this.instance.size(); instance_idx++) {		  ArrayList<String> record = this.instance.get(instance_idx);		  // Determine if this record is same as the candidate		  boolean isSame = true;		  for(int attr_idx = 0; attr_idx < record.size(); attr_idx++) {			if(!record.get(attr_idx).equals(candidateRecord.get(attr_idx))) {			  isSame = false;			  break;			}		  }		  // If so, PK constraint is now violated		  if(isSame)		  	return false;		}		// That this instruction is executed implies there was no duplicacy		return true;	  }	}	boolean checkFKConstraint(ArrayList<String> candidateRecord) {	  // candidateRecord is considered to be ordered as specified in the table attributes	  // If this table does not refer any other table, FK constraint trivially satisfied	  if(this.foreignKey.size() == 0)	    return true;	  // Check for each foreign key in this table's foreign keys	  for(ForeignKey FK : this.foreignKey) {		String refedTableName = FK.getReferencedTable();		Table refedTable = SimpleDBMSParser.loadTableFromDB(refedTableName);		if(refedTable == null) {		  return false;		}		ArrayList<String> refingAttrs = FK.getReferencingAttribute();		ArrayList<String> refedAttrs = FK.getReferencedAttribute();		// Order referenced/ing attributes as specified in the referenced table's attribute		ArrayList<String> temp_refingAttrs = new ArrayList<String>();		ArrayList<String> temp_refedAttrs = new ArrayList<String>();				// For each attribute in the table that is being referenced,		for(Attribute attr : refedTable.getAttributes()) {		  String attrName = attr.getAttributeName();		  // For each attribute in this table,		  for(int idx = 0; idx < refedAttrs.size(); idx++) {			if(refedAttrs.get(idx).equalsIgnoreCase(attrName)) {			  temp_refingAttrs.add(refingAttrs.get(idx));			  temp_refedAttrs.add(refedAttrs.get(idx));			}		  }		}		refingAttrs = temp_refingAttrs;		refedAttrs = temp_refedAttrs;		ArrayList<String> candidateFK = new ArrayList<String>();		// Extract attributes from candidate record that constitute FK		for(int idx = 0; idx < this.attributes.size(); idx++) {		  String attrName = this.attributes.get(idx).getAttributeName();		  if(constitutesFK(attrName, refedTableName))		    candidateFK.add(candidateRecord.get(idx));		}		// Check if there is a record with same FK		for(int instance_idx = 0; instance_idx < refedTable.getInstance().size(); instance_idx++) {		  ArrayList<String> record = refedTable.getInstance().get(instance_idx);		  ArrayList<String> recordFK = new ArrayList<String>();		  // For each record, extract its FK attributes		  for(int attr_idx = 0; attr_idx < record.size(); attr_idx++) {			String recordAttr = record.get(attr_idx);			if(constitutesFK(refedTable.getAttributes().get(attr_idx).getAttributeName(), refedTableName))			  recordFK.add(recordAttr);		  }		  // Determine if this record's FK is same as the candidate's FK		  boolean isSame = true;		  for(int attr_idx = 0; attr_idx < recordFK.size(); attr_idx++) {			if(!recordFK.get(attr_idx).equalsIgnoreCase(candidateFK.get(attr_idx))) {			  isSame = false;			  break;			}		  }		  // If so, immediately return true		  if(isSame) {		  	return true;		  }		} // for each record	  } // for each fk	  // That this code is executed means FK constraint not satisfied.	  return false;	}	boolean checkRecordDeletable(ArrayList<String> record) {	  // For each tables that refers to this table,	  for(String refingTableName : this.tablesReferencedBy){ 		Table refingTable = SimpleDBMSParser.loadTableFromDB(refingTableName);		ForeignKey refingTableFK = refingTable.getForeignKeyByName(this.tableName);		ArrayList<String> refingAttributes = refingTableFK.getReferencingAttribute();		ArrayList<String> refedAttributes = refingTableFK.getReferencedAttribute();		ArrayList<ArrayList<String>> refingInstance = refingTable.getInstance();		// Check if the foreign key that references to this table contains a non-nullable attribute.		boolean nonNullExists = false;		for(String refingAttrStr : refingAttributes) {		  Attribute refingAttr = null;		  for(Attribute attr : refingTable.getAttributes()) {		    if(attr.getAttributeName().equalsIgnoreCase(refingAttrStr))		      refingAttr = attr;		  }		  // If a single referencing FK attribute is not nullable,		  // Check if there really is a referencing record that references this record.		  if(!refingAttr.getNullable()) {		    nonNullExists = true;		    break;		  }		}		// If all referencing FK attributes are nullable,		// Check other tables that references this table.		if(!nonNullExists)		  continue;		ArrayList<Integer> refingAttributesIndices = new ArrayList<Integer>();		ArrayList<Integer> refedAttributesIndices = new ArrayList<Integer>();		// For each referencing attributes, store its index in its attributes.		for(String refingAttrStr : refingAttributes) { 		  int idx = 0;		  for(int attr_idx = 0; attr_idx < refingTable.getAttributes().size(); attr_idx++) {		    Attribute attr = refingTable.getAttributes().get(attr_idx);		    if(attr.getAttributeName().equalsIgnoreCase(refingAttrStr)) { 		      idx = attr_idx;		      break;		    }		  }		  refingAttributesIndices.add(idx);		}		// For each referenced attributes which is in this table, store its index in this attributes.		for(String refedAttrStr : refedAttributes) { 		  int idx = 0;		  for(int attr_idx = 0; attr_idx < this.attributes.size(); attr_idx++) {		    Attribute attr = this.attributes.get(attr_idx);		    if(attr.getAttributeName().equalsIgnoreCase(refedAttrStr)) { 		      idx = attr_idx;		      break;		    }		  }		  refedAttributesIndices.add(idx);		}		// Compare the referencing record with this record.		for(ArrayList<String> refingRecord : refingInstance) {		  boolean attr_match = true;		  // If a single record attribute different from a corresponding referencing record attribute,		  // Then no match. Check for other tables.		  for(int idx_indices = 0; idx_indices < refedAttributesIndices.size(); idx_indices++) {			if(!record.get(refedAttributesIndices.get(idx_indices)).equalsIgnoreCase(refingRecord.get(refingAttributesIndices.get(idx_indices))))			  attr_match = false;		  }		  // Not nullable, and a referencing record actually references this record.		  // no deal.		  if(attr_match)		    return false;		}	  }   	  return true;	}	void nullifyReferenceingRecord(ArrayList<String> record) {	  for(String refingTableName : this.tablesReferencedBy) {		Table refingTable = SimpleDBMSParser.loadTableFromDB(refingTableName);		ForeignKey refingFK = refingTable.getForeignKeyByName(this.tableName);		ArrayList<String> refingAttributes = refingFK.getReferencingAttribute();		ArrayList<String> refedAttributes = refingFK.getReferencedAttribute();		ArrayList<ArrayList<String>> refingInstance = refingTable.getInstance();		// Check if the foreign key that references to this table contains a non-nullable attribute.		boolean nonNullExists = false;		for(String refingAttrStr : refingAttributes) {		  Attribute refingAttr = null;		  for(Attribute attr : refingTable.getAttributes()) {			if(attr.getAttributeName().equalsIgnoreCase(refingAttrStr))			  refingAttr = attr;		  }		  // Non-nullable attribute found. mark it.		  if(!refingAttr.getNullable()) {		    nonNullExists = true;		    break;		  }		}		// If there is no nullable FK attribute, proceed.		if(!nonNullExists) {		  ArrayList<Integer> refingAttributesIndices = new ArrayList<Integer>();		  ArrayList<Integer> refedAttributesIndices = new ArrayList<Integer>();		  // For each referencing attributes, store its index in its attributes.		  for(String refingAttr : refingAttributes) { 			int idx_attr = 0; 		    for(int idx = 0; idx < refingTable.getAttributes().size(); idx++) {			  if(refingTable.getAttributes().get(idx).getAttributeName().equalsIgnoreCase(refingAttr)) {			    idx_attr = idx;			    break;			  }		    }		    refingAttributesIndices.add(idx_attr);		  }		  // For each referenced attributes which is in this table, store its index in this attributes.		  for(String refedAttr : refedAttributes) {			int idx_attr = 0; 		    for(int idx = 0; idx < this.getAttributes().size(); idx++) {			  if(this.getAttributes().get(idx).getAttributeName().equalsIgnoreCase(refedAttr)) {			    idx_attr = idx;			    break;			  }		    }			refedAttributesIndices.add(idx_attr);		  }		  // Compare the referencing record with this record.		  for(int idx = 0; idx < refingInstance.size(); idx++) {			ArrayList<String> refingRecord = refingInstance.get(idx);			boolean attr_match = true;		    // If a single record attribute different from a corresponding referencing record attribute,		    // Then no match. Check for other tables.			for(int idx_indices = 0; idx_indices < refedAttributesIndices.size(); idx_indices++) {			  if(!record.get(refedAttributesIndices.get(idx_indices)).equalsIgnoreCase(refingRecord.get(refingAttributesIndices.get(idx_indices))))			    attr_match = false;			}			// Match found.			if(attr_match) {			  // Set the FK attributes as null			  for(int idx_indices = 0; idx_indices < refingAttributesIndices.size(); idx_indices++)			    refingRecord.set(refingAttributesIndices.get(idx_indices), "null");			  refingInstance.set(idx, refingRecord);			  refingTable.setInstance(refingInstance);			  try {			    // Overwrite the change to DB.			    DatabaseEntry key = new DatabaseEntry(refingTable.getTableName().getBytes("UTF-8"));			    DatabaseEntry value = new DatabaseEntry();				SimpleDBMSParser.serialBinding.objectToEntry(refingTable, value);				SimpleDBMSParser.myDatabase.delete(null, key);				SimpleDBMSParser.myDatabase.put(null, key, value);				SimpleDBMSParser.myDatabase.sync();			  }			  catch (UnsupportedEncodingException e) {			    e.printStackTrace();			  }			}		  }		}	  }	}	/* getters */	String getTableName() {	  return this.tableName;	}	String getAliasName() {	  return this.aliasName;	}	ArrayList<Attribute> getAttributes() {	  return this.attributes;	}	ArrayList<ForeignKey> getForeignKey() {	  return this.foreignKey;	}	ForeignKey getForeignKeyByName(String table_name) {	  for(ForeignKey FK : this.foreignKey) {	    if(FK.getReferencedTable().equals(table_name))	      return FK;	  }	  return null;	}	ArrayList<String> getPrimaryKey() {	  return this.primaryKey;	}	int getReferenceCount() {	  return this.referenceCount;	}	ArrayList<ArrayList<String>> getInstance() {	  return this.instance;	}	ArrayList<String> getTablesReferencedBy() {	  return this.tablesReferencedBy;	}	/* setters */	void setTableName(String tableName) {	  this.tableName = tableName;	}	void setAliasName(String aliasName) {	  this.aliasName = aliasName;	}	void setInstance(ArrayList<ArrayList<String>> instance) {	  this.instance = instance;	}}class Attribute implements Serializable {	String tableName;	String attributeName;	String type;	boolean nullable;	Attribute() {	  this.tableName = null;	  this.attributeName = null;	  this.type = null;	  this.nullable = true;	}	Attribute(String tableName, String attributeName, String type, boolean nullable) {	  this.tableName = tableName;	  this.attributeName = attributeName;	  this.type = type;	  this.nullable = nullable;	}	/* getters */	String getTableName() {	  return this.tableName;	}	String getAttributeName() {	  return this.attributeName;	}	String getType() {	  return this.type;	}	boolean getNullable() {	  return this.nullable;	}	/* setters */	void setTableName(String tableName) {	  this.tableName = tableName;	}	void setAttributeName(String attributeName) {	  this.attributeName = attributeName;	}	void setType(String type) {	  this.type = type;	}	void setNullable(boolean nullable) {	  this.nullable = nullable;	}}class ForeignKey implements Serializable { 	ArrayList<String> referencingAttribute; 	ArrayList<String> referencedAttribute; 	String referencedTable;	ForeignKey() {	  this.referencingAttribute = new ArrayList<String>();	  this.referencedAttribute = new ArrayList<String>();	  this.referencedTable = null;	}		ForeignKey(		ArrayList<String> referencingAttribute,		ArrayList<String> referencedAttribute,		String referencedTable	) {	  this.referencingAttribute = referencingAttribute;	  this.referencedAttribute = referencedAttribute;	  this.referencedTable = referencedTable;	}	/* getters */	ArrayList<String> getReferencingAttribute() {	  return this.referencingAttribute;	}	ArrayList<String> getReferencedAttribute() {	  return this.referencingAttribute;	}	String getReferencedTable() {	  return this.referencedTable;	}}class TableElementList implements Serializable {  	ArrayList<TableColumn> columnList;  	ArrayList<TableConstraint> constraintList;  	TableElementList() {  	    this.columnList = new ArrayList<TableColumn>();  	    this.constraintList = new ArrayList<TableConstraint>();  	}  	void addColumn(TableColumn column) {  	  this.columnList.add(column);  	}  	void addConstraint(TableConstraint constraint) {  	  this.constraintList.add(constraint);  	}	/* getters */	ArrayList<TableColumn> getColumnList() {	  return this.columnList;	}	ArrayList<TableConstraint> getConstraintList() {	  return this.constraintList;	}}class TableColumn implements Serializable {  	String columnName;  	String type;  	boolean nullable;  	TableColumn(String columnName, String type, boolean nullable) {  	    this.columnName = columnName;  	    this.type = type;  	    this.nullable = nullable;  	}  	/* getters */	String getColumnName() {	  return this.columnName;	}	String getType() {	  return this.type;	}	boolean getNullable() {	  return this.nullable;	}}class TableConstraint implements Serializable {  	boolean is_PK;  	ArrayList<String> attributes;  	String referencedTable;  	ArrayList<String> referencedAttributes;  	TableConstraint(  		boolean is_PK, // true  		ArrayList<String> attributes    ) {		this.is_PK = is_PK;		this.attributes = attributes;    }  	TableConstraint(  		boolean is_PK, // false  		ArrayList<String> attributes,  		String referencedTable,  		ArrayList<String> referencedAttributes    ) {		this.is_PK = is_PK;		this.attributes = attributes;		this.referencedTable = referencedTable;		this.referencedAttributes = referencedAttributes;    }	/* getters */	boolean getIs_PK() {	  return this.is_PK;	}	ArrayList<String> getAttributes() {	  return this.attributes;	}	String getReferencedTable() {	  return this.referencedTable;	}	ArrayList<String> getReferencedAttribute() {	  return this.referencedAttributes;	}}PARSER_END(SimpleDBMSParser)SKIP : { < SPACE: " " > | <  TAB : "\t" > | < EOL : "\r\n" | "\n" | "\r" > }//key word on top of < LEGAL_IDENTIFIER > so keyword is detected firstTOKEN : /* Keywords */{  < EXIT : "exit" >| < INT : "int" >| < CHAR : "char" >| < DATE : "date" >| < CREATE : "create" >| < TABLE : "table" >| < DROP : "drop" >| < DESC : "desc" >| < INSERT : "insert" >| < INTO : "into" >| < DELETE : "delete" >| < SELECT : "select" >| < SHOW : "show" >| < TABLES : "tables" >| < VALUES : "values" >| < WHERE : "where" >| < PRIMARY : "primary" >| < FOREIGN : "foreign" >| < KEY : "key" >| < REFERENCES : "references" >| < NULL : "null" >| < NOT : "not" >| < OR : "or" >| < AS : "as" >| < FROM : "from" >| < AND : "and" >| < IS : "is" >| < ASTERISK : "*" >}//building blocks for the functions belowTOKEN :	//used in functions{  //< END : < SEMICOLON >(< SPACE > | < TAB >)*< EOL >>  < END : < SEMICOLON >(< SPACE > | < TAB >)*< EOL >>| < SEMICOLON : ";" >| < LEFT_PAREN : "(" >| < RIGHT_PAREN : ")" >| < COMMA : "," >| < PERIOD : "." >| < COMP_OP : ">" | "<" | ">=" | "<=" | "!=" | "=" >| < INT_VALUE : (< SIGN >)? (< DIGIT >)+>| < LEGAL_IDENTIFIER : < ALPHABET > (< ALPHABET > | < UNDERSCORE >)* >| < DATE_VALUE : < NNNN >"-"< NN >"-"< NN > >| < CHAR_STRING : < QUOTE >(< NON_QUOTE_CHARACTER >)*< QUOTE > >}//used to make token block aboveTOKEN :	//used to make token{  < NNNN : < DIGIT >< DIGIT >< DIGIT >< DIGIT > >| < NN : < DIGIT >< DIGIT > >| < ALPHABET : [ "a"-"z", "A"-"Z" ] >| < SIGN : "+" | "-" >	| < DIGIT : [ "0"-"9" ] >| < UNDERSCORE : "_" >| < QUOTE : "'" >| < NON_QUOTE_SPECIAL_CHARACTERS: "!" | "@" | "#" | "$" | "%" | "^" | "&" | "-" | "{" | "}" | "[" | "]" |									"~" | "`" | "+" | "*" | "_" | "=" | "\\" | "(" | ")" | "<" | ">" |									"?" | "," | "." | "\n" | "\t" | "\r" | ":" | ";" | "|" | "/">| < NON_QUOTE_CHARACTER : < DIGIT > | < ALPHABET > | < NON_QUOTE_SPECIAL_CHARACTERS > | < SPACE > >| < UNEXPECTED:~[] >}void command() :{}{  (  	queryList()  )| (    < EXIT >    (    	< SEMICOLON > | < END > 	)    {      // Close Database	  if (cursor != null) cursor.close();      if (myDatabase != null) myDatabase.close();	  if (classDB != null) classDB.close();  	  if (myDbEnvironment != null) myDbEnvironment.close();            System.exit(0);    }  )}void queryList() :{  int q;}{  (    q = query()    (  	    (	      //when query ends at end of line	      < END >		  {		    printMessage(q);		  	//prompt when new query starts		    System.out.print("DB_2014-15703> ");		  }		)	  | (	   		//for query sequence with semicolon concatenated with another query		  < SEMICOLON >		    {		      printMessage(q);		 	}		)	)  )+}int query() :{  int q;}{  //query returns q, which is used to print correct message by printMessage(q)  (    (      createTableQuery()	    {	      q = PRINT_CREATE_TABLE;	    }	  )	| (	  	dropTableQuery()	  	{	  	  q = PRINT_DROP_TABLE;	  	}	  )	| (	  	descQuery()	  	{	  	  q = PRINT_DESC;	  	}	  )	| (	  	insertQuery()	  	{	  	  q = PRINT_INSERT;	  	}	  )	| (	  	deleteQuery()	  	{	  	  q = PRINT_DELETE;	  	}	  )	| (	  	selectQuery()	  	{	  	  q = PRINT_SELECT;	  	}	  )	| (	  	showTablesQuery()	  	{	  	  q = PRINT_SHOW_TABLES;	  	} 	  )	)  {   	return q;  }}//below regex for queries are similar to the ones in grammar file. /// 0. easy onesvoid dropTableQuery() :{  String tableName;  Table table;}{	<  DROP >	< TABLE >	tableName = tableName()	{	  try { 		table = loadTableFromDB(tableName);		if(table == null) {		  System.out.println("No such table");		  return;		}		// Check if there are some tables referencing this table. If so, do not drop.		if(table.getReferenceCount() > 0) {		  System.out.println("Drop table has failed: '"+ tableName +"' is referenced by other table");		  return;		}		// For every foreign key, decrement reference counts of tables referenced by the being-dropped table.		for(ForeignKey foreignKey : table.getForeignKey()) {		  String referencedTableName = foreignKey.getReferencedTable();		  Table referencedTable = loadTableFromDB(referencedTableName);		  if(referencedTable != null) {			referencedTable.decrementReferenceCount();			// Overwrite the change to DB.		    DatabaseEntry key = new DatabaseEntry(referencedTableName.getBytes("UTF-8"));		    DatabaseEntry value = new DatabaseEntry();			serialBinding.objectToEntry(referencedTable, value);			myDatabase.delete(null, key);	 		myDatabase.put(null, key, value);	 		myDatabase.sync();		  }		}		// Drop the table from the DB.		myDatabase.delete(null, new DatabaseEntry(tableName.getBytes("UTF-8")));		myDatabase.sync();		System.out.println("'"+ tableName +"' table is dropped");	  }	  catch(Exception e) {	    e.printStackTrace();	  }	}}void descQuery() :{  String tableName;  Table table = null;}{	< DESC >	tableName = tableName()	{	  table = loadTableFromDB(tableName);	  if(table == null) {		System.out.println("No such table");		return;	  }	  System.out.println("-------------------------------------------------------------");	  System.out.println("table_name [" + tableName + "]");	  System.out.println(String.format("%-25s %-15s %-15s %-15s", "column_name", "type", "null", "key"));	  String name, type, nullable, kind;	  boolean isPK = false;	  boolean isFK = false;	  // For every attribute, determine the strings.	  for(Attribute attr : table.getAttributes()){		isPK = false;		isFK = false;		name = attr.getAttributeName();		type = attr.getType();		// Check if nullable.		if(attr.getNullable())		  nullable = "Y";		else		  nullable = "N";		// Check if the attribute is a part of PK.		for(String pk : table.getPrimaryKey())		  if(pk.equalsIgnoreCase(name))			isPK = true;		// Check if the attribute is a part of FK.		for(ForeignKey fk : table.getForeignKey())		  for(String referencingAttr : fk.getReferencingAttribute())			if(referencingAttr.equalsIgnoreCase(name))			  isFK = true;		// If both, the attribute is both a PK and a FK.	    if(isPK && isFK)		  kind = "PRI/FOR";		else if(isPK)		  kind = "PRI";		else if(isFK)		  kind = "FOR";		else		  kind = "";		System.out.println(String.format("%-25s %-15s %-15s %-15s", name, type, nullable, kind));	  }	    System.out.println("-------------------------------------------------------------");	}}void showTablesQuery() :{  String tableName = null;  DatabaseEntry foundKey;  DatabaseEntry foundData;}{	< SHOW>	< TABLES >	{	  foundKey = new DatabaseEntry();	  foundData = new DatabaseEntry();	  // There is no table in the DB.	  if(cursor.getFirst(foundKey, foundData, LockMode.DEFAULT) == OperationStatus.NOTFOUND) { 	    System.out.println("There is no table");	    return;	  }	  System.out.println("----------------");	  // Print all tables in the DB.	  do {		try {		  tableName = new String(foundKey.getData(), "UTF-8");		  System.out.println(tableName);		}		catch (UnsupportedEncodingException e) {			e.printStackTrace();		}	  } while(cursor.getNext(foundKey, foundData,LockMode.DEFAULT) == OperationStatus.SUCCESS);	  System.out.println("----------------");	}}/// 0. easy ones /// 1. for createTableQuery()void createTableQuery() :{	String tableName;	TableElementList tableElements;	Table createdTable;}{  < CREATE >  < TABLE >  tableName = tableName()  tableElements = tableElementList()  {    // Make a table out of table name and its elements, and store it to the DB.	try { 	  createdTable = makeTable(tableName, tableElements);      storeTableToDB(createdTable);    }    catch(Exception e) {	  System.out.println(e.getMessage());	  SimpleDBMSParser.ReInit(System.in);      System.out.print("DB_2014-15703> ");    }  }}TableElementList tableElementList() :{  TableElementList tableElements = new TableElementList();}{  < LEFT_PAREN >  tableElements = tableElement(tableElements)  (    < COMMA >    tableElements = tableElement(tableElements)  )*  < RIGHT_PAREN >  {	return tableElements;  }}TableElementList tableElement(TableElementList tableElements) :{}{  (    tableElements = columnDefinition(tableElements)  | tableElements = tableConstraintDefinition(tableElements)  )  {	return tableElements;  }}TableElementList columnDefinition(TableElementList tableElements) :{  String columnName;  String dataType;  boolean nullable;  Token T = null;  TableColumn column;}{  columnName = columnName()  dataType = dataType()  (    < NOT >    T = < NULL >  )?  {    nullable = T == null ? true : false;	column = new TableColumn(columnName, dataType, nullable);	tableElements.addColumn(column);	return tableElements;  }}TableElementList tableConstraintDefinition(TableElementList tableElements) :{}{  (    tableElements = primaryKeyConstraint(tableElements)  | tableElements = referentialConstraint(tableElements)  )  {	return tableElements;  }}TableElementList primaryKeyConstraint(TableElementList tableElements) :{  boolean is_PK = true;  ArrayList<String> primaryKeyList;  TableConstraint constraint;}{  < PRIMARY >  < KEY >  primaryKeyList = columnNameList()  {    constraint = new TableConstraint(is_PK, primaryKeyList);    tableElements.addConstraint(constraint);    return tableElements;  }}TableElementList referentialConstraint(TableElementList tableElements) :{  boolean is_PK = false;  ArrayList<String> foreignKeyList;  TableConstraint constraint;  String tableName;  ArrayList<String> referencedAttributes;}{  < FOREIGN >  < KEY >  foreignKeyList = columnNameList()  < REFERENCES >  tableName = tableName()  referencedAttributes = columnNameList()  {	constraint = new TableConstraint(is_PK, foreignKeyList, tableName, referencedAttributes);	tableElements.addConstraint(constraint);	return tableElements;  }}ArrayList<String> columnNameList() :{  String columnName;  ArrayList<String> columnNames = new ArrayList<String>();}{  < LEFT_PAREN >  columnName = columnName()  {	columnNames.add(columnName);  }  (    < COMMA >    columnName = columnName()    {      columnNames.add(columnName);    }  )*  < RIGHT_PAREN >  {	return columnNames;  }}String dataType() :{  Token type = null;  Token val = null;  Token left = null;  Token right = null;  String result;}{  (	type = < INT >  | (	  type = < CHAR >	  left = < LEFT_PAREN >	  val = < INT_VALUE >	  right = < RIGHT_PAREN >	)  | type = < DATE >  )  {    // INT or DATE	if(type.image.equalsIgnoreCase("int") || type.image.equalsIgnoreCase("date")) {	  result = type.image;	}		// CHAR	else {	  // Its value is not right.	  if(Integer.parseInt(val.image) <  1) {	    result = "CharLengthError";	  }	  // Good case.	  else { 	    result = type.image + left.image + val.image + right.image;	  }	}	return result;  }}String tableName() :{  Token T;}{  T = < LEGAL_IDENTIFIER >  {    return T.image;  }}String columnName() :{  Token T;}{  T = < LEGAL_IDENTIFIER >  {	return T.image;  }}/// 1. for createTableQuery/// 2. for selectQueryvoid selectQuery() :{  ArrayList<String> selectedColumns = null;  ArrayList<String> header = null;  ArrayList<ArrayList<String>> products = null;}{	< SELECT >	selectedColumns = selectList() // select columns	products = tableExpression() // produce producted records	{	  header = new ArrayList<String>();	  // Asterisk : print everything	  if(selectedColumns.size() == 1 && selectedColumns.get(0).equals("*")) {		for(int idx = 0; idx < products.get(0).size(); idx++) {		  String tablehdr = products.get(0).get(idx);		  String tableName = tablehdr.split(":", 4)[0];		  String aliasName = tablehdr.split(":", 4)[1];		  String attrName = tablehdr.split(":", 4)[2];		  String attrType = tablehdr.split(":", 4)[3];		  String attrIdxPair = attrName + ":" + Integer.toString(idx);		  header.add(attrIdxPair);		}	  }	  // Normal case	  else {	    // selectedColumn == "tableName:columnName:aliasName"		for(String selectedColumn : selectedColumns) {		  String tableName = selectedColumn.split(":", 3)[0];		  String columnName = selectedColumn.split(":", 3)[1];		  String aliasName = selectedColumn.split(":", 3)[2];		  int clmIdxInProducts = 0;		  // No tablename speicfied in select clause		  if(tableName.equals("")) {			int count = 0;		    for(int idx = 0; idx < products.get(0).size(); idx++) {			  String tablehdr = products.get(0).get(idx);			  String tableName_hdr = tablehdr.split(":", 4)[0];			  String aliasName_hdr = tablehdr.split(":", 4)[1];			  String attrName_hdr = tablehdr.split(":", 4)[2];			  String attrType_hdr = tablehdr.split(":", 4)[3];			  // If column name matches, update count and index			  if(columnName.equalsIgnoreCase(attrName_hdr)) {			    count++;			    clmIdxInProducts = idx;			  }			}			// if count is not exactly one, error			if(count == 0 || count > 1) {		  	  System.out.println("Selection has failed: fail to resolve '" + columnName + "'");	  	  	  SimpleDBMSParser.ReInit(System.in);      	      System.out.print("DB_2014-15703> ");      	      return;			}			// if alias specified, use it. if not, don't.			String attrIdxPair = "";			if(aliasName.length() == 0) {			  attrIdxPair = columnName + ":" + Integer.toString(clmIdxInProducts);			}			else { 			  attrIdxPair = aliasName + ":" + Integer.toString(clmIdxInProducts);			}			header.add(attrIdxPair);		  }		  // tablename specified in select cause		  else {		    int tableCount = 0;			int count = 0;			for(int idx = 0; idx < products.get(0).size(); idx++) { 			  String tablehdr = products.get(0).get(idx);			  String tableName_hdr = tablehdr.split(":", 4)[0];			  String aliasName_hdr = tablehdr.split(":", 4)[1];			  String attrName_hdr = tablehdr.split(":", 4)[2];			  String attrType_hdr = tablehdr.split(":", 4)[3];			  // if table name matches with either table name or alias name in header			  if(tableName.equalsIgnoreCase(tableName_hdr) || tableName.equalsIgnoreCase(aliasName_hdr)) {				tableCount++;				// and column name matches, 			    if(columnName.equalsIgnoreCase(attrName_hdr)) {			      count++;			      clmIdxInProducts = idx;			    }			  }			}			// Must check only if table count is 0 or not, it will suffice			if(tableCount == 0) {			  System.out.println("Selection has failed: '" + tableName + "' does not exist");	  	  	  SimpleDBMSParser.ReInit(System.in);      	      System.out.print("DB_2014-15703> ");      	      return;			}			if(count == 0 || count > 1) {		  	  System.out.println("Selection has failed: fail to resolve '" + columnName + "'");	  	  	  SimpleDBMSParser.ReInit(System.in);      	      System.out.print("DB_2014-15703> ");      	      return;			}			// if alias specified, use it. if not, don't.			String attrIdxPair = "";			if(aliasName.length() == 0) { 			  attrIdxPair = columnName + ":" + Integer.toString(clmIdxInProducts);			}			else { 			  attrIdxPair = aliasName + ":" + Integer.toString(clmIdxInProducts);			}			header.add(attrIdxPair);		  }		} // for(String selectedColumn : selectedColumns)	  } // normal case	  printSelected(header, products);	}}ArrayList<String> selectList() :{  ArrayList<String> selectedColumns = new ArrayList<String>();}{  < ASTERISK >  {	selectedColumns.add("*");	return selectedColumns;  }| (  	selectedColumns = selectedColumn(selectedColumns)  	(  	  < COMMA >  	  selectedColumns = selectedColumn(selectedColumns)  	)*  )  {	return selectedColumns;  }}ArrayList<String> selectedColumn(ArrayList<String> selectedColumns) :{  String tableName = "";  String columnName = "";  String aliasName = "";}{  (	(	  //tableName & columnName are same token <LEGAL_IDENITFIER >, so need to lookahead 2	  LOOKAHEAD(2)	  tableName = tableName()	  < PERIOD >	)?	columnName = columnName()	(	  < AS >	  aliasName = columnName()	)?  )  {	selectedColumns.add(tableName + ":" + columnName + ":" + aliasName);	return selectedColumns;  }}ArrayList<ArrayList<String>> tableExpression():{  ArrayList<ArrayList<String>> products = null;  ArrayList<ArrayList<String>> products_filtered = null;  ArrayList<Integer> booleanList = null;}{	(	  products = fromClause()	  (		booleanList = whereClause(products)	  )?	)	{	  products_filtered = new ArrayList<ArrayList<String>>();	  // add header	  products_filtered.add(products.get(0));	  	  if(booleanList != null) {		for(int idx = 0; idx < booleanList.size(); idx++) {		  if(booleanList.get(idx) == 1)		    products_filtered.add(products.get(idx+1));		}	  }	  else {	    for(int idx = 0; idx < products.size()-1; idx++) {	      products_filtered.add(products.get(idx+1));	    }	  }	  return products_filtered;	}}ArrayList<ArrayList<String>> fromClause():{  ArrayList<ArrayList<String>> products;}{  < FROM >  products = tableReferenceList()  {	return products;  }}ArrayList<ArrayList<String>> tableReferenceList():{  ArrayList<ArrayList<String>> products;  ArrayList<Table> referencedTables = new ArrayList<Table>();  Table table;}{  (    table = referedTable()    {	  referencedTables.add(table);    }    (      < COMMA >      table = referedTable()      {        referencedTables.add(table);      }    )*  )  {	products = product(referencedTables);	return products;  }}// maybe should return a tableTable referedTable()://ArrayList<ArrayList<String>> referedTable():{  //ArrayList<ArrayList<String>> instance;  String tableName = "";  String aliasName = "";}{  (      tableName = tableName()  (    < AS >    aliasName = tableName()  )?)  {	Table table = loadTableFromDB(tableName);	if(table == null) {	  System.out.println("Selection has failed: '" + tableName + "' does not exist");	  SimpleDBMSParser.ReInit(System.in);      System.out.print("DB_2014-15703> ");      return null;    }	if(aliasName.length() != 0)	  table.setAliasName(aliasName);    return table;  }}ArrayList<Integer> whereClause(ArrayList<ArrayList<String>> products) :{  ArrayList<Integer> booleanList;}{  < WHERE >  booleanList = booleanValueExpression(products)  {	return booleanList;  }}ArrayList<Integer> booleanValueExpression(ArrayList<ArrayList<String>> products) :{  ArrayList<Integer> booleanBefore = null;  ArrayList<Integer> booleanAfter = null;}{  booleanBefore = booleanTerm(products)  (    < OR >    booleanAfter = booleanTerm(products)    {	  for(int idx = 0; idx < booleanBefore.size(); idx++) {		if(booleanBefore.get(idx) == -1) {		  if(booleanAfter.get(idx) == 1)		    booleanBefore.set(idx, 1);		  else		    booleanBefore.set(idx, -1);		}		else if(booleanAfter.get(idx) == -1) {		  if(booleanBefore.get(idx) == 1)		    booleanBefore.set(idx, 1);		  else		    booleanBefore.set(idx, -1);		}		else {		  if(booleanBefore.get(idx) == 1 && booleanAfter.get(idx) == 1)		    booleanBefore.set(idx, 1);		  else		    booleanBefore.set(idx, booleanBefore.get(idx) + booleanAfter.get(idx));		}	  }    }  )*  {	return booleanBefore;  }}ArrayList<Integer> booleanTerm(ArrayList<ArrayList<String>> products):{  ArrayList<Integer> booleanBefore = null;  ArrayList<Integer> booleanAfter = null;}{  booleanBefore = booleanFactor(products)  (    < AND >    booleanAfter = booleanFactor(products)    {	  for(int idx = 0; idx < booleanBefore.size(); idx++) {	    if(booleanBefore.get(idx) == -1) {	      if(booleanAfter.get(idx) == 0)	        booleanBefore.set(idx, 0);	      else	        booleanBefore.set(idx, -1);	    }	    else if(booleanAfter.get(idx) == -1) {	      if(booleanBefore.get(idx) == 0)	        booleanBefore.set(idx, 0);	      else	        booleanBefore.set(idx, -1);	    }	    else	      booleanBefore.set(idx, booleanBefore.get(idx) * booleanAfter.get(idx));	  }    }  )*  {	return booleanBefore;  }}ArrayList<Integer> booleanFactor(ArrayList<ArrayList<String>> products):{  ArrayList<Integer> booleanList;  boolean not = false;}{  (    < NOT >    {	  not = true;    }  )?  booleanList = booleanTest(products)  {	if(not) {	  for(int idx = 0; idx < booleanList.size(); idx++) {		if(booleanList.get(idx) == 1)		  booleanList.set(idx, 0);		else if(booleanList.get(idx) == 0)		  booleanList.set(idx, 1);	  }	}	return booleanList;  }}ArrayList<Integer> booleanTest(ArrayList<ArrayList<String>> products):{  ArrayList<Integer> booleanList;}{  (    booleanList = predicate(products)  | booleanList = parenthesizedBooleanExpression(products)  )  {	return booleanList;  }}ArrayList<Integer> parenthesizedBooleanExpression(ArrayList<ArrayList<String>> products):{  ArrayList<Integer> booleanList;}{  < LEFT_PAREN >  booleanList = booleanValueExpression(products)  < RIGHT_PAREN >  {	return booleanList;  }}ArrayList<Integer> predicate(ArrayList<ArrayList<String>> products):{  ArrayList<Integer> booleanList;}{  (    //comparisonPredicate & nullPredicate can both start with tableName()< PERIOD >columnName()    //so need to lookahead 4    LOOKAHEAD(4)    booleanList = comparisonPredicate(products)  | booleanList = nullPredicate(products)  )  {	 return booleanList;  }}ArrayList<Integer> comparisonPredicate(ArrayList<ArrayList<String>> products):{  ArrayList<Integer> booleanList;  String operand0 = "";  String operand1 = "";  Token OPERATOR_T = null;}{	operand0 = compOperand()	OPERATOR_T = < COMP_OP >	operand1 = compOperand()	{	  String operator = OPERATOR_T.image;	  String leftOrigin = operand0.split(":", 3)[0];	  String leftType = operand0.split(":", 3)[1];	  String leftValue = operand0.split(":", 3)[2];	  String rightOrigin = operand1.split(":", 3)[0];	  String rightType = operand1.split(":", 3)[1];	  String rightValue = operand1.split(":", 3)[2];	  // Initialize booleanList	  booleanList = new ArrayList<Integer>();	  // booleanList idx <=> products idx + 1	  for(int _ = 0; _ < products.size() - 1; _++)	    booleanList.add(0);	  // Raw string format: 'STRING'. Need to get rid of apostrophes	  if(leftType.equals("char"))	    leftValue = leftValue.substring(1, leftValue.length()-1);	  if(rightType.equals("char"))	    rightValue = rightValue.substring(1, rightValue.length()-1);	  // Comparable OP Comparable	  if(leftOrigin.equals("cmp") && rightOrigin.equals("cmp")) {		// Valid comparison		if(leftType.equals(rightType)) {		  int result = compare(leftValue, rightValue, operator, leftType);		  // result is always fixed		  for(int idx = 0; idx < booleanList.size(); idx++)		    booleanList.set(idx, result);		  return booleanList;		}				// Uncomparable comparison		else {		  System.out.println("Where clause try to compare incomparable values");	  	  SimpleDBMSParser.ReInit(System.in);      	  System.out.print("DB_2014-15703> ");      	  return null;		}	  }	  // Comparable OP Column	  else if(leftOrigin.equals("cmp") && rightOrigin.equals("clm")) {		// Rename variables		String rightTableName = rightType;		String rightColumnName = rightValue;		int rightColumnCount = columnNameCount(rightTableName, rightColumnName, products.get(0));		// Check if refers to non specified table		if(rightColumnCount < 0) {		  System.out.println("Where clause try to reference tables which are not specified");	  	  SimpleDBMSParser.ReInit(System.in);      	  System.out.print("DB_2014-15703> ");      	  return null;		}		// Check if column count is exactly one or not		if(rightColumnCount == 0) {		  System.out.println("Where clause try to reference non existing column");	  	  SimpleDBMSParser.ReInit(System.in);      	  System.out.print("DB_2014-15703> ");      	  return null;		}		else if(rightColumnCount > 1) {		  System.out.println("Where clause contains ambiguous reference");	  	  SimpleDBMSParser.ReInit(System.in);      	  System.out.print("DB_2014-15703> ");      	  return null;		}		// Check if rightColumnName refers to an existing column		String tableName = "";		String aliasName = "";		String attrName = "";		String attrType = "";		int idx_table = 0;		for(; idx_table < products.get(0).size(); idx_table++) {		  String tablehdr = products.get(0).get(idx_table);		  		  tableName = tablehdr.split(":", 4)[0];		  aliasName = tablehdr.split(":", 4)[1];		  attrName = tablehdr.split(":", 4)[2];		  attrType = tablehdr.split(":", 4)[3];		  // If table name specified		  if(rightTableName.length() != 0) { 		    if(rightTableName.equalsIgnoreCase(tableName) || rightTableName.equalsIgnoreCase(aliasName)) {		      if(rightColumnName.equalsIgnoreCase(attrName)) { 		        break;		      }		    }		  }		  // if table name not specified		  else {		    if(rightColumnName.equalsIgnoreCase(attrName)) { 		      break;		    }		  }		}		// Check if types are same		if(!attrType.equalsIgnoreCase(leftType)) {		  System.out.println("Where clause try to compare incomparable values");	  	  SimpleDBMSParser.ReInit(System.in);      	  System.out.print("DB_2014-15703> ");      	  return null;		}		// Proceed with comparison		for(int idx = 0; idx < booleanList.size(); idx++) {		  booleanList.set(idx, compare(leftValue, products.get(idx+1).get(idx_table), operator, leftType));		}		return booleanList;	  }	  // Column OP Comparable	  else if(leftOrigin.equals("clm") && rightOrigin.equals("cmp")) {		// Rename variables		String leftTableName = leftType;		String leftColumnName = leftValue;		int leftColumnCount = columnNameCount(leftTableName, leftColumnName, products.get(0));		// Check if refers to non specified table		if(leftColumnCount < 0) {		  System.out.println("Where clause try to reference tables which are not specified");	  	  SimpleDBMSParser.ReInit(System.in);      	  System.out.print("DB_2014-15703> ");      	  return null;		}		// Check if column count is exactly one or not		if(leftColumnCount == 0) {		  System.out.println("Where clause try to reference non existing column");	  	  SimpleDBMSParser.ReInit(System.in);      	  System.out.print("DB_2014-15703> ");      	  return null;		}		else if(leftColumnCount > 1) {		  System.out.println("Where clause contains ambiguous reference");	  	  SimpleDBMSParser.ReInit(System.in);      	  System.out.print("DB_2014-15703> ");      	  return null;		}		// Check if leftColumnName refers to an existing column		String tableName = "";		String aliasName = "";		String attrName = "";		String attrType = "";		int idx_table = 0;		for(; idx_table < products.get(0).size(); idx_table++) {		  String tablehdr = products.get(0).get(idx_table);		  		  tableName = tablehdr.split(":", 4)[0];		  aliasName = tablehdr.split(":", 4)[1];		  attrName = tablehdr.split(":", 4)[2];		  attrType = tablehdr.split(":", 4)[3];		  		  // If table name specified		  if(leftTableName.length() != 0) { 		    if(leftTableName.equalsIgnoreCase(tableName) || leftTableName.equalsIgnoreCase(aliasName)) {		      if(leftColumnName.equalsIgnoreCase(attrName)) { 		        break;		      }		    }		  }		  // if table name not specified		  else {		    if(leftColumnName.equalsIgnoreCase(attrName)) { 		      break;		    }		  }		}		// Check if types are same		if(!attrType.equalsIgnoreCase(rightType)) {		  System.out.println("Where clause try to compare incomparable values");	  	  SimpleDBMSParser.ReInit(System.in);      	  System.out.print("DB_2014-15703> ");      	  return null;		}		// Proceed with comparison		for(int idx = 0; idx < booleanList.size(); idx++) {		  booleanList.set(idx, compare(products.get(idx+1).get(idx_table), rightValue, operator, rightType));		}		return booleanList;	  }	  // Column OP Column	  else { 		// Rename variables		String leftTableName = leftType;		String leftColumnName = leftValue;		String rightTableName = rightType;		String rightColumnName = rightValue;		int leftColumnCount = columnNameCount(leftTableName, leftColumnName, products.get(0));		int rightColumnCount = columnNameCount(rightTableName, rightColumnName, products.get(0));		// Check if refers to non specified table		if(leftColumnCount < 0 || rightColumnCount < 0) {		  System.out.println("Where clause try to reference tables which are not specified");	  	  SimpleDBMSParser.ReInit(System.in);      	  System.out.print("DB_2014-15703> ");      	  return null;		}		// Check if column count is exactly one or not		if(leftColumnCount == 0 || rightColumnCount == 0) {		  		  System.out.println("Where clause try to reference non existing column");	  	  SimpleDBMSParser.ReInit(System.in);      	  System.out.print("DB_2014-15703> ");      	  return null;		}		else if(leftColumnCount > 1 || rightColumnCount > 1) {		  System.out.println("Where clause contains ambiguous reference");	  	  SimpleDBMSParser.ReInit(System.in);      	  System.out.print("DB_2014-15703> ");      	  return null;		}		// Check if left/rightColumnName refers to an existing column		String tableName = "";		String aliasName = "";		String attrName = "";		String attrType = "";		String leftAttrType = "";		String rightAttrType = "";		int idx_table = 0;		int idx_left = 0;		int idx_right = 0;		for(; idx_table < products.get(0).size(); idx_table++) {		  String tablehdr = products.get(0).get(idx_table);		  		  tableName = tablehdr.split(":", 4)[0];		  aliasName = tablehdr.split(":", 4)[1];		  attrName = tablehdr.split(":", 4)[2];		  attrType = tablehdr.split(":", 4)[3];		  // If left table name specified		  if(leftTableName.length() != 0) { 		    if(leftTableName.equalsIgnoreCase(tableName) || leftTableName.equalsIgnoreCase(aliasName)) {		      if(leftColumnName.equalsIgnoreCase(attrName)) { 		        idx_left = idx_table;		        leftAttrType = attrType;		      }		    }		  }		  // If left table name not specified		  else {			if(leftColumnName.equalsIgnoreCase(attrName)) {			  idx_left = idx_table;			  leftAttrType = attrType;			}		  }		  // If right table name specified		  if(rightTableName.length() != 0) { 		    if(rightTableName.equalsIgnoreCase(tableName) || rightTableName.equalsIgnoreCase(aliasName)) {		      if(rightColumnName.equalsIgnoreCase(attrName)) { 		        idx_right = idx_table;		        rightAttrType = attrType;		      }		    }		  }		  // if right table name not specified		  else {		    if(rightColumnName.equalsIgnoreCase(attrName)) { 		      idx_right = idx_table;		      rightAttrType = attrType;		    }		  }		}	    // Check if types are same	    if(!leftAttrType.equalsIgnoreCase(rightAttrType)) {		  System.out.println("Where clause try to compare incomparable values");	  	  SimpleDBMSParser.ReInit(System.in);      	  System.out.print("DB_2014-15703> ");      	  return null;		}		// Proceed with comparison		for(int idx = 0; idx < booleanList.size(); idx++) {		  booleanList.set(idx, compare(products.get(idx+1).get(idx_left), products.get(idx+1).get(idx_right), operator, leftAttrType));		}		return booleanList;	  }	}}String compOperand():{  String tableName = "";  String columnName = "";  String compVal = "";}{  compVal = comparableValue()  {	return "cmp:" + compVal;  }| (  	(  	  //tableName & columnName are same token <LEGAL_IDENITFIER >, so need to lookahead 2  	  LOOKAHEAD(2)  	  tableName = tableName()  	  < PERIOD >  	)?  	columnName = columnName() ) {	return "clm:" + tableName + ":" + columnName; }}String comparableValue():{  Token T;  String type;}{  (	T = < INT_VALUE >	{	  type = "int";	}  | T = < CHAR_STRING >  	{  	  type = "char";  	}  | T = < DATE_VALUE >  	{	  type = "date";  	}  )  {	return type + ":" + T.image;  }}ArrayList<Integer> nullPredicate(ArrayList<ArrayList<String>> products):{  String tableName = "";  String columnName = "";  String nullOperation = "";  ArrayList<Integer> booleanList;}{  (    //tableName & columnName are same token <LEGAL_IDENITFIER >, so need to lookahead 2    LOOKAHEAD(2)    tableName = tableName()    < PERIOD >  )?  columnName = columnName()  nullOperation = nullOperation()  {	int columnIdx = 0;        // Table name specified    if(!tableName.equals("")) { 	  int tableNameCount = tableNameCount(tableName, products.get(0));		  if(tableNameCount == 0) {		System.out.println("Where clause try to reference tables which are not specified");		SimpleDBMSParser.ReInit(System.in);	    System.out.print("DB_2014-15703> ");	    return null;	  }	  else if(tableNameCount > 1) {		System.out.println("Where clause contains ambiguous reference");		SimpleDBMSParser.ReInit(System.in);	    System.out.print("DB_2014-15703> ");	    return null;	  }	  // Check if columnName really appears in the table	  boolean columnInTable = false;	  for(int idx = 0; idx < products.get(0).size(); idx++) {		String tablehdr = products.get(0).get(idx);		String tableName_ = tablehdr.split(":", 4)[0];		String aliasName = tablehdr.split(":", 4)[1];		String attrName = tablehdr.split(":", 4)[2];		String attrType = tablehdr.split(":", 4)[3];	  	if(tableName.equalsIgnoreCase(tableName_) || tableName.equalsIgnoreCase(aliasName)) {		  if(columnName.equalsIgnoreCase(attrName)) { 		    columnInTable = true;		    columnIdx = idx;		    break;		  }	  	}	  }	  if(!columnInTable) {		System.out.println("Where clause try to reference non existing column");		SimpleDBMSParser.ReInit(System.in);	    System.out.print("DB_2014-15703> ");	    return null;	  }	}	// Table name not specified: only clue is column name	else {	  int column_count = 0;	  // Check for column name duplicacy	  for(int idx = 0; idx < products.get(0).size(); idx++) {		String tablehdr = products.get(0).get(idx);		String tableName_ = tablehdr.split(":", 4)[0];		String aliasName = tablehdr.split(":", 4)[1];		String attrName = tablehdr.split(":", 4)[2];		String attrType = tablehdr.split(":", 4)[3];		if(columnName.equalsIgnoreCase(attrName)) { 		  column_count++;		  columnIdx = idx;		}	  }	  if(column_count > 1) { 	 	System.out.println("Where clause contains ambiguous reference");		SimpleDBMSParser.ReInit(System.in);	    System.out.print("DB_2014-15703> ");	    return null;	  }	  if(column_count == 0) {		System.out.println("Where clause try to reference non existing column");		SimpleDBMSParser.ReInit(System.in);	    System.out.print("DB_2014-15703> ");	    return null;	  }	}	// Initialize boolean list	booleanList = new ArrayList<Integer>();	for(int _ = 0; _ < products.size()-1; _++)	  booleanList.add(0);	// for each boolean list index	for(int idx = 0; idx < booleanList.size(); idx++) {	  // is not null	  if(nullOperation.equals("is not null")) {		if(!products.get(idx+1).get(columnIdx).equalsIgnoreCase("null"))		  booleanList.set(idx, 1);		else		  booleanList.set(idx, 0);	  }	  else {		if(!products.get(idx+1).get(columnIdx).equalsIgnoreCase("null"))		  booleanList.set(idx, 0);		else		  booleanList.set(idx, 1);	  }	}	return booleanList;  }}String nullOperation():{ boolean not = false;}{  < IS >  (    < NOT >    {	  not = true;    }  )?  < NULL >  {    return not ? "is not null" : "is null";  }}/// 2. for selectQuery/// 3. for insert,deletevoid insertQuery() :{  String tableName;  ArrayList<ArrayList<String>> columnValuePair;}{	< INSERT >	< INTO >	tableName = tableName()	columnValuePair = insertColumnsAndSource()	{	  Table table;	  ArrayList<String> columns = columnValuePair.get(0);	  ArrayList<String> tvalues = columnValuePair.get(1);	  ArrayList<String> targetRecord = new ArrayList<String>();	  table = loadTableFromDB(tableName);	  if(table == null) {	    System.out.println("No such table");	    return;	  }	  ArrayList<Attribute> attributes = table.getAttributes();	  // Validity check	  // column names are specified in the query	  if(columns != null) {	    // Size mismatch		if(columns.size() != tvalues.size() || columns.size() != attributes.size()) {		  System.out.println("Insertion has failed: Types are not matched");		  return;		}		// Duplicacy in query column		for(String column : columns) {		  ArrayList<String> tempColumns = new ArrayList<String>(columns);		  tempColumns.remove(column);		  for(String tempColumn : tempColumns) {			if(tempColumn.equalsIgnoreCase(column)) {			  System.out.println("Insertion has faield: Types are not matched");			  return;			}		  }		} // Duplicacy check		// Order columns and tvalues as specified in this table's attributes		ArrayList<String> temp_columns = new ArrayList<String>();		ArrayList<String> temp_tvalues = new ArrayList<String>();		for(Attribute attr : attributes) {		  String attrName = attr.getAttributeName();		  for(int idx = 0; idx < attributes.size(); idx++) {			if(columns.get(idx).equals(attrName)) {			  temp_columns.add(columns.get(idx));			  temp_tvalues.add(tvalues.get(idx));			}		  }		}		// If size mismatch, at least one column does not exist		if(temp_columns.size() != attributes.size()) {		  // Find the missing column		  for(String column : columns) {			boolean columnInThisAttributes = false;		    		    for(Attribute attr : attributes) {		      if(column.equalsIgnoreCase(attr.getAttributeName())) {		        columnInThisAttributes = true;		        break;		      }		    }		    if(!columnInThisAttributes) {		  	  System.out.println("Insertion has failed: '" + column + "' does not exist");		      return;		    }		  }		}		// no missing column. proceed.		columns = temp_columns;		tvalues = temp_tvalues;		// Existence, type, nullable check on query column w.r.t. query column		for(int idx = 0; idx < tvalues.size(); idx++) {		  String column = columns.get(idx);		  String tvalue = tvalues.get(idx);		  Attribute attribute = null;		  for(Attribute tempAttr : attributes)			if(tempAttr.getAttributeName().equalsIgnoreCase(column)) { 			  attribute = tempAttr;			  break;			}		  String attrType = attribute.getType();		  if(attrType.startsWith("char")) attrType = "char";		  boolean attrNullable = attribute.getNullable();		  String columnType = tvalue.split(":", 2)[0];		  String columnValue = tvalue.split(":", 2)[1];		  // type mismatch		  if(!columnType.equalsIgnoreCase(attrType) && !columnType.equals("null")) {			System.out.println("Insertion has failed: Types are not matched");			return;		  }		  // Type is char: truncate if exceeds size		  if(columnType.equals("char")) {			int attrTypeSize = attribute.getType().length();			// attribute type string: char(n)			int charSize = Integer.parseInt(attribute.getType().substring(5, attrTypeSize - 1));			// remove quotes			columnValue = columnValue.substring(1, columnValue.length()-1);			if(columnValue.length() > charSize)			  columnValue = columnValue.substring(0, charSize);		  }		  // Type is null: check if really nullable		  if(columnType.equals("null") && !attrNullable) {		    System.out.println("Insertion has failed: '" + attribute.getAttributeName() + "' is not nullable");		    return;		  }		} // Existence, type, nullable check on query column	  } // column names are specified in the query	  // column names are NOT specified in the query	  else {		// Size mismatch		if(attributes.size() != tvalues.size()) {		  System.out.println("Insertion has failed: Types are not matched");		  return;		}		// Existence, type, nullable check on query record w.r.t. actual attribute		for(int idx = 0; idx < tvalues.size(); idx++) {		  String tvalue = tvalues.get(idx);		  Attribute attribute = attributes.get(idx);		  String attrType = attribute.getType();		  if(attrType.startsWith("char")) attrType = "char";		  boolean attrNullable = attribute.getNullable();		  		  String columnType = tvalue.split(":", 2)[0];		  String columnValue = tvalue.split(":", 2)[1];		  // type mismatch		  if(!columnType.equalsIgnoreCase(attrType) && !columnType.equals("null")) {			System.out.println("Insertion has failed: Types are not matched");			return;		  }		  // Type is char: truncate if exceeds size		  if(columnType.equals("char")) {			int attrTypeSize = attribute.getType().length();			// attribute type string: char(n)			int charSize = Integer.parseInt(attribute.getType().substring(5, attrTypeSize - 1));			// remove quotes			columnValue = columnValue.substring(1, columnValue.length()-1);			if(columnValue.length() > charSize)			  columnValue = columnValue.substring(0, charSize);		  }		  // Type is null: check if really nullable		  if(columnType.equals("null") && !attrNullable) {		    System.out.println("Insertion has failed: '" + attribute.getAttributeName() + "' is not nullable");		    return;		  }		} // Existence, type, nullable check on query column	  } // column names are NOT specified in the query	  // Build a target record	  for(String tvalue : tvalues) {	    String targetValue = tvalue.split(":", 2)[1];	    targetRecord.add(targetValue);	  }	  if(!table.checkPKConstraint(targetRecord)) {	    System.out.println("Insertion has failed: Primary key duplication");	    return;	  }	  if(!table.checkFKConstraint(targetRecord)) {		System.out.println("Insertion has failed: Referential integrity violation");	    return;	  }	  table.addInstance(targetRecord);	  try { 		// Overwrite the change to DB.	    DatabaseEntry key = new DatabaseEntry(table.getTableName().getBytes("UTF-8"));	    DatabaseEntry value = new DatabaseEntry();  	    serialBinding.objectToEntry(table, value);	    myDatabase.delete(null, key);	    myDatabase.put(null, key, value);	    myDatabase.sync();	  }	  catch (UnsupportedEncodingException e) {		e.printStackTrace();	  }	  System.out.println("The row is inserted");	  return;	}}void deleteQuery() :{  String tableName = "";  ArrayList<ArrayList<String>> products = new ArrayList<ArrayList<String>>();  ArrayList<ArrayList<String>> new_products = new ArrayList<ArrayList<String>>();  ArrayList<Integer> booleanList = null;  Table table = null;  int deleted_count = 0;  int spared_count = 0;}{	< DELETE >	< FROM > 	tableName = tableName()	{	  table = loadTableFromDB(tableName);	  // Make header	  ArrayList<String> header = new ArrayList<String>();	  String aliasName = table.getAliasName();	  for(Attribute attr : table.getAttributes()) {	    header.add(tableName + ":" + aliasName + ":" + attr.getAttributeName() + ":" + (attr.getType().startsWith("char") ? "char" : attr.getType()));	  }	  products.add(header);	  products.addAll(table.getInstance());	}	(		booleanList = whereClause(products)	)?	{	  // where clause is not specified	  if(booleanList == null) { 		booleanList = new ArrayList<Integer>();		for(int _ = 0; _ < table.getInstance().size(); _++)		  booleanList.add(1);	  }	  // for each record in instance,	  for(int idx = 0; idx < booleanList.size(); idx++) {	    // if it does not satisfy the where condition, it will be spared		if(booleanList.get(idx) != 1)		  new_products.add(products.get(idx + 1));		// if it does satisfy the where condition,		else {		  // If deletable, delete.		  if(table.checkRecordDeletable(products.get(idx + 1))) {			deleted_count++;			table.nullifyReferenceingRecord(products.get(idx + 1));		  }		  // If not, spare.		  else {			new_products.add(products.get(idx + 1));			spared_count++;		  }		}	  }	  table.setInstance(new_products);	  try { 	    // Overwrite the change to DB.	    DatabaseEntry key = new DatabaseEntry(table.getTableName().getBytes("UTF-8"));	    DatabaseEntry value = new DatabaseEntry();	    serialBinding.objectToEntry(table, value);	    myDatabase.delete(null, key);	    myDatabase.put(null, key, value);	    myDatabase.sync();	  }	  catch (UnsupportedEncodingException e) {	    e.printStackTrace();	  }	  System.out.println(Integer.toString(deleted_count) + " row(s) are deleted");	  if(spared_count != 0)	 	System.out.println(Integer.toString(spared_count) + " row(s) are not deleted due to referential integrity");	  return;	}}ArrayList<ArrayList<String>> insertColumnsAndSource() :{  ArrayList<String> columns = null;  ArrayList<String> tvalues = null;}{	(	  columns = columnNameList()	)?	tvalues = valueList()	{	  ArrayList<ArrayList<String>> columnValuePair =  new ArrayList<ArrayList<String>>();	  columnValuePair.add(columns);	  columnValuePair.add(tvalues);	  return columnValuePair;	}}ArrayList<String> valueList() :{  ArrayList<String> values = new ArrayList<String>();  String tvalue;}{	< VALUES >	< LEFT_PAREN >	tvalue = value()	{	  values.add(tvalue);	}	(	  < COMMA >	  tvalue = value()	  {	    values.add(tvalue);	  }	)*	< RIGHT_PAREN >	{	  return values;	}}String value() :{  String tvalue;}{  (    < NULL >    {	  tvalue = "null:null";    }  | tvalue = comparableValue()  )  {	return tvalue;  }}/// 3. for insert,delete